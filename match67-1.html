<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/6/21101096_a_b_m_danial_cse422_06_assignment03_fall2024_-_A.B.M_DANIAL.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/22101856_rafid_bin_bakhtiar_cse422_07_assignment03_fall2024_-_RAFID_BIN_BAKHTIAR.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101856_Rafid_Bin_Bakhtiar_CSE422_07_Assignment03_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F-kIlIYlVv0-p3wdmR2uIxmnBAx5faVd
"""

#task1
def alpha_beta_pruning(depth, is_maximizing_player, alpha, beta):

    if depth == 0:
        if is_maximizing_player:
            return -1
        else:
            return 1

    if is_maximizing_player:
        max_eval = float('-inf')
        for i in range(2):
            eval = alpha_beta_pruning(depth - 1, False, alpha, beta)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for i in range(2):
            eval = alpha_beta_pruning(depth - 1, True, alpha, beta)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break
        return min_eval

def simulate_battle(current_player):
    total_rounds = 3
    round_winners = []

    for i in range(1, total_rounds + 1):
        if current_player == 0:
            winner = alpha_beta_pruning(5, True, float('-inf'), float('inf'))
        else:
            winner = alpha_beta_pruning(5, False, float('-inf'), float('inf'))

        if winner == -1:
            round_winners.append('Scorpion')
        else:
            round_winners.append('Sub-Zero')

        current_player = 1 - current_player

    if round_winners.count('Scorpion') &gt; round_winners.count('Sub-Zero'):
        game_winner = 'Scorpion'
    else:
        game_winner = 'Sub-Zero'

    print(f"Game Winner: {game_winner}")
    print(f"Total Rounds Played: {total_rounds}")
    for i, winner in enumerate(round_winners):
        print(f"Winner of Round {i + 1}: {winner}")

inp = int(input())
if inp == 0:
    simulate_battle(0)
else:
    simulate_battle(1)

#task2
class Tree:
  def __init__(self):
    self.value = None
    self.left = None
    self.right = None

<a name="1"></a><font color="#00FF00"><a href="match67-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

def insertion(depth, val):
  no_of_nodes = 2 ** (depth + 1) -1
  node = []
  for i in range(no_of_nodes):
    node.append(Tree())
  for  i in range(2**depth - 1):
    node[i].left = node[2*i + 1]
    node[i].right = node[2*i + 2]
</font><a name="3"></a><font color="#00FFFF"><a href="match67-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>


  starting_node = 2 ** depth - 1

  for i in range(len(val)):
    node[starting_node + i].value = val[i]
  return node[0]

def minimax_pruning(node,depth, maximize, alpha, beta, maxdepth):
</font>  if depth == maxdepth:
    return node.value

  if maximize:
<a name="0"></a><font color="#FF0000"><a href="match67-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_16.gif"/></a>

    cost = - float("inf")
    if node.left:
      cost = max(cost, minimax_pruning(node.left, depth + 1, False, alpha, beta, maxdepth))
    if node.right:
      cost = max(cost, minimax_pruning(node.right, depth + 1, False, alpha, beta, maxdepth))
    alpha = max(alpha, cost)
    if alpha &gt;= beta:
      return cost
    return cost
  else:
    cost = float("inf")
    if node.left:
      cost = min(cost, minimax_pruning(node.left, depth + 1, True, alpha, beta, maxdepth))
    if node.right:
      cost = min(cost, minimax_pruning(node.right, depth + 1, True, alpha, beta, maxdepth))
    beta = min(beta, cost)
    if alpha &gt;= beta:
      return cost
    return cost

def dark_magic(node, depth, maximize, alpha, beta, maxdepth):
</font>  if depth==maxdepth:
    return node.value
  if maximize:
<a name="2"></a><font color="#0000FF"><a href="match67-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

    cost = -float("inf")
    if node.left:
      cost = max(cost, dark_magic(node.left, depth + 1, True, alpha, beta, maxdepth))
    if node.right:
      cost = max(cost, dark_magic(node.right, depth + 1, True, alpha, beta, maxdepth))
    alpha = max(alpha, cost)
    if alpha &gt;= beta:
      return cost
    return cost
</font><a name="4"></a><font color="#FF00FF"><a href="match67-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>


def pacman_game(c, depth, outcomes):
  root = insertion(depth, outcomes)
  minimax = minimax_pruning(root, 0, True, -float("inf"), float("inf"), depth)
  dark_pruning = dark_magic(root, 0, True, -float("inf"), float("inf"), depth)
  return minimax, dark_pruning
</font>
inp = int(input())
depth = 3
outcomes = [3,6,2,3,7,1,2,0]
left=max(outcomes[0:4])
right=max(outcomes[4:])
if left &lt;= right:
  path = 'right'
elif right &lt;= left:
  path = 'left'
else:
  path = 'anypath'

minimax, dark_pruning = pacman_game(inp, depth, outcomes)
x = minimax
y = dark_pruning - inp
if x&lt;y:
    print(f"The new minimax value is {y}. Pacman goes {path} and uses dark magic")
else:
    print(f"The minimax value is {x}. Pacman does not use dark magic")</pre>
</body>
</html>
