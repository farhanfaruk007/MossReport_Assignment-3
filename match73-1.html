<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/1/22299540_samihaislam_sec01_assignmnent3_-_SAMIHA_ISLAM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/11/21201509_nusratmahmud_cse422_11_lab_assignment3_fall2024_-_NUSRAT_MAHMUD.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201509_NusratMahmud_CSE422_11_Lab_Assignment3_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o8y1h-AiTFj5pb4aNsrF9d-2FqprBuva
"""

#task1(Mortal Kombat game)

start_player = int(input("Enter the starting player (0 for Scorpion, 1 for Sub-Zero): "))

import random

<a name="0"></a><font color="#FF0000"><a href="match73-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

class GameTree:
    def __init__(self, level, current_player, max_level, node_value=None):
        self.level = level
        self.current_player = current_player
        self.max_level = max_level
        self.node_value = node_value
        self.branches = []

    def construct_tree(self):
        if self.level &lt; self.max_level:
</font>            branch_count = 0
<a name="7"></a><font color="#0000FF"><a href="match73-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

            while branch_count &lt; 2:  # 2ta child nodes create kore
                next_player = 1 - self.current_player
                sub_tree = GameTree(self.level + 1, next_player, self.max_level)
                self.branches.append(sub_tree)
</font>                sub_tree.construct_tree()
                branch_count += 1

<a name="8"></a><font color="#00FFFF"><a href="match73-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

    def assign_leaf_value(self, value):
        self.node_value = value


def collect_leaves(tree_node):
    if not tree_node.branches:
        return [tree_node]
    leaves = []
</font>    branch_index = 0
    while branch_index &lt; len(tree_node.branches):
        sub_branch = tree_node.branches[branch_index]
        leaves.extend(collect_leaves(sub_branch))
        branch_index += 1
<a name="4"></a><font color="#FF00FF"><a href="match73-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

    return leaves


def alpha_beta_pruning(tree_node, alpha, beta, is_maximizing_turn):
    if tree_node.level == tree_node.max_level or not tree_node.branches:
        return tree_node.node_value

    if is_maximizing_turn:
</font>        highest_score = float('-inf')
        branch_index = 0
        while branch_index &lt; len(tree_node.branches):
<a name="5"></a><font color="#FF0000"><a href="match73-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

            branch = tree_node.branches[branch_index]
            branch_score = alpha_beta_pruning(branch, alpha, beta, False)
            if branch_score is not None:
                highest_score = max(highest_score, branch_score)
                alpha = max(alpha, branch_score)
            if beta &lt;= alpha:
</font>                break
            branch_index += 1
        return highest_score
    else:
        lowest_score = float('inf')
        branch_index = 0
        while branch_index &lt; len(tree_node.branches):
<a name="6"></a><font color="#00FF00"><a href="match73-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

            branch = tree_node.branches[branch_index]
            branch_score = alpha_beta_pruning(branch, alpha, beta, True)
            if branch_score is not None:
                lowest_score = min(lowest_score, branch_score)
                beta = min(beta, branch_score)
            if beta &lt;= alpha:
</font>                break
            branch_index += 1
        return lowest_score


def simulate_mortal_kombat_game(first_player):
    depth_limit = 5  # Maximum depth of the tree
    match_rounds = 3  # Number of rounds to simulate
    round_outcomes = []

    round_count = 0
    while round_count &lt; match_rounds:
        root = GameTree(0, first_player, depth_limit)
        root.construct_tree()
        all_leaves = collect_leaves(root)
        leaf_values = [random.choice([-1, 1]) for _ in all_leaves]

        leaf_index = 0
        while leaf_index &lt; len(all_leaves):
            leaf = all_leaves[leaf_index]
            value = leaf_values[leaf_index]
            leaf.assign_leaf_value(value)
            leaf_index += 1

        winning_value = alpha_beta_pruning(root, float('-inf'), float('inf'), first_player == 0)
        round_winner = "Scorpion" if winning_value == -1 else "Sub-Zero"
        round_outcomes.append(round_winner)
        first_player = 1 - first_player

        round_count += 1

    scorpion_score = round_outcomes.count("Scorpion")
    sub_zero_score = round_outcomes.count("Sub-Zero")
    overall_winner = "Scorpion" if scorpion_score &gt; sub_zero_score else "Sub-Zero"

    print(f"Game Winner: {overall_winner}")
    print(f"Total Rounds Played: {match_rounds}")
    for idx, result in enumerate(round_outcomes, start=1):
        print(f"Winner of Round {idx}: {result}")


simulate_mortal_kombat_game(start_player)

#task2
def pacman_game(magic_cost):
<a name="1"></a><font color="#00FF00"><a href="match73-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

    leaf_nodes = [3, 6, 2, 3, 7, 1, 2, 0]

    optimal_value = alpha_beta_pruning(0, 0, True, leaf_nodes, float('-inf'), float('inf'))

    left_magic_value = leaf_nodes[1] - magic_cost
    right_magic_value = leaf_nodes[4] - magic_cost
    optimal_with_magic = max(left_magic_value, right_magic_value)
</font>
    while optimal_with_magic &gt; optimal_value:
        if left_magic_value &gt; right_magic_value:
            print(f"The new minimax value is {optimal_with_magic}. Pacman goes left and uses dark magic")
        else:
            print(f"The new minimax value is {optimal_with_magic}. Pacman goes right and uses dark magic")
        break
<a name="9"></a><font color="#FF00FF"><a href="match73-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

    else:
        print(f"The minimax value is {optimal_value}. Pacman does not use dark magic")

def alpha_beta_pruning(depth, node_index, maximizing_player, leaf_nodes, alpha, beta):
    if depth == 3:
        return leaf_nodes[node_index]

    if maximizing_player:
</font>        max_eval = float('-inf')
        i = 0
        while i &lt; 2:
<a name="2"></a><font color="#0000FF"><a href="match73-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

            eval_value = alpha_beta_pruning(depth + 1, node_index * 2 + i, False, leaf_nodes, alpha, beta)
            if eval_value is not None:
                max_eval = max(max_eval, eval_value)
                alpha = max(alpha, eval_value)
            if beta &lt;= alpha:
</font>                break
            i += 1
        return max_eval
    else:
        min_eval = float('inf')
        j = 0
        while j &lt; 2:
<a name="3"></a><font color="#00FFFF"><a href="match73-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

            eval_value = alpha_beta_pruning(depth + 1, node_index * 2 + j, True, leaf_nodes, alpha, beta)
            if eval_value is not None:
                min_eval = min(min_eval, eval_value)
                beta = min(beta, eval_value)
            if beta &lt;= alpha:
</font>                break
            j += 1
        return min_eval


t = int(input("Enter the magic cost: "))
pacman_game(t)</pre>
</body>
</html>
