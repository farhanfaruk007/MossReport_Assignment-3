<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/18/22101082_SaditArshadSakib_CSE422_Assignment03_Fall2024_-_SADIT_ARSHAD_SAKIB.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/18/22101082_SaditArshadSakib_CSE422_Assignment03_Fall2024_-_SADIT_ARSHAD_SAKIB.py<p></p><pre>
# -*- coding: utf-8 -*-
"""CSE422_Lab3_Sadit.ipynb

Automatically generated by Colab.

Original file is located at
<a name="3"></a><font color="#00FFFF"><a href="match132-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

    https://colab.research.google.com/drive/1p6VJcfuOXdpkTT3xPEOQjacM1p5EuB9z

# **PART 1**
"""

import random

def alpha_beta_pruning(depth, starting_player, alpha, beta):
    if depth == 0:
</font>        return random.choice([-1, 1])  # Randomly choose a value

    if starting_player == 1:  # Sub-Zero's turn
        max_eval = float('-inf')
        for _ in range(2):  # Branching factor = 2
            checker = alpha_beta_pruning(depth - 1, False, alpha, beta)
            max_eval = max(max_eval, checker)
            alpha = max(alpha, checker)
            if alpha &gt;= beta:
                break
        return max_eval

    else:  # Scorpion's turn
        min_eval = float('inf')
        for _ in range(2):
            checker = alpha_beta_pruning(depth - 1, True, alpha, beta)
            min_eval = min(min_eval, checker)
            beta = min(beta, checker)
            if alpha &gt;= beta:
                break
        return min_eval

def simulate_mortal_kombat(starting_player,rounds):
    rounds = rounds
    current_player = starting_player
    round_results = []

<a name="2"></a><font color="#0000FF"><a href="match132-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

    for round_number in range(rounds):
        winner = alpha_beta_pruning(5, current_player == 1, float('-inf'), float('inf')) #depth 5
        if winner == 1:
            round_results.append("Sub-Zero")
        else:
            round_results.append("Scorpion")
        current_player = 1 - current_player  # swap player turns
</font>
    scorpion_wins = round_results.count("Scorpion")
    sub_zero_wins = round_results.count("Sub-Zero")

    if scorpion_wins &gt; sub_zero_wins:
      game_winner = "Scorpion"
    else:
      game_winner = "Sub-Zero"
    return (game_winner, rounds, round_results)

#Driver code
#starting_player = int(input("Select the starting player: "))
#number_of_rounds = int(input("Enter the number of rounds: "))

starting_player = 0
number_of_rounds = 3

results = simulate_mortal_kombat(starting_player,number_of_rounds)

print(f"Game Winner: {results[0]}")
print(f"Total Rounds Played: {results[1]}")
print(f"Round Results:")
for i in range(len(results[2])):
  print(f"Winner of Round {i+1}: {results[2][i]}")

<a name="1"></a><font color="#00FF00"><a href="match132-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

"""# **PART 2**"""

def pacman_game(c):
    outcomes = [3, 6, 2, 3, 7, 1, 2, 0]
    # Minimax with alpha-beta pruning
    def minimax(depth, highest_val, alpha, beta, start, end):
        if depth == 0:
            return max(outcomes[start:end])

        if highest_val:
            max_eval = float('-inf')
            for i in range(2):  # Two branches
                eval = minimax(
</font>                    depth - 1, False, alpha, beta, start + i * (len(outcomes) // 4), start + (i + 1) * (len(outcomes) // 4)
                )
                max_eval = max(max_eval, eval)
                alpha = max(alpha, eval)
                if alpha &gt;= beta:
                    break
            return max_eval
        else:
            min_eval = float('inf')
            for i in range(2):
                eval = minimax(
                    depth - 1, True, alpha, beta, start + i * (len(outcomes) // 4), start + (i + 1) * (len(outcomes) // 4)
                )
<a name="0"></a><font color="#FF0000"><a href="match132-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_17.gif"/></a>

                min_eval = min(min_eval, eval)
                beta = min(beta, eval)
                if alpha &gt;= beta:
                    break
            return min_eval

    # Without dark magic
    root_value = minimax(2, True, float('-inf'), float('inf'), 0, len(outcomes))

    # With dark magic subtract c
    left_subtree = max(outcomes[:4]) - c
    right_subtree = max(outcomes[4:]) - c

    best_with_dark_magic = max(left_subtree, right_subtree)
    use_dark_magic = best_with_dark_magic &gt; root_value

    if use_dark_magic:
        if left_subtree &gt; right_subtree:
            print(f"The new minimax value is {left_subtree}. Pacman goes left and uses dark magic.")
        else:
            print(f"The new minimax value is {right_subtree}. Pacman goes right and uses dark magic.")
    else:
      print(f"The minimax value is {root_value}. Pacman does not use dark magic.")

#Driver code
pacman_game(2)
pacman_game(5)</font></pre>
</body>
</html>
