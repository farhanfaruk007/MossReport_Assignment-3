<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/22101024_angkon_dutta_joy_cse422_07_assignment03_fall2024_-_ANGKON_DUTTA_JOY.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/22101362_plabon_mondal_cse422_07_assignment03_fall2024_-_PLABON_MONDAL.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101362_Plabon_Mondal_CSE422_07_Assignment03_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dtgUzDZz1qRk2DhUOxnNUYl0eZRqKWg3

**Part 1**
"""

#Task-01

import random

starter_player = int(input("Who'll start first: "))

is_maximizer_starting = None

if starter_player == 1:
    is_maximizer_starting = True

elif starter_player == 0:
    is_maximizer_starting = False

else:
    print("Invalid input. Please try later!")
    exit()

bb_ff = 2
tree_dpth = 4
total_leaf_nodes = bb_ff**tree_dpth

def generate_leaf_nodes():
    leaf_values = []
    for p in range(total_leaf_nodes):
        value = random.choice([-1, 1])
        leaf_values.append(value)
    return leaf_values

rounds_to_play = 3

def a_b_prun(n_values, current_dpth, n_index, is_maxi, alfa, bita):
<a name="0"></a><font color="#FF0000"><a href="match202-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_17.gif"/></a>

    if current_dpth == tree_dpth:
        return n_values[n_index]

    if is_maxi:
        maxi_eval = float('-inf')
        for p in range(bb_ff):
            calc = a_b_prun(n_values, current_dpth + 1, n_index * bb_ff + p, False, alfa, bita)
            maxi_eval = max(maxi_eval, calc)
            alfa = max(alfa, calc)
            if bita &lt;= alfa:
                break
        return maxi_eval

    else:
        mini_eval = float('inf')
        for q in range(bb_ff):
            calc = a_b_prun(n_values, current_dpth + 1, n_index * bb_ff + q, True, alfa, bita)
            mini_eval = min(mini_eval, calc)
            bita = min(bita, calc)
            if bita &lt;= alfa:
                break
        return mini_eval
</font>
game_results = []

for round_num in range(rounds_to_play):
    if round_num == 0:
        leaf_node_values = generate_leaf_nodes()
        game_outcome = a_b_prun(leaf_node_values, 0, 0, is_maximizer_starting, float('-inf'), float('inf'))
        game_results.append(game_outcome)
    elif is_maximizer_starting:
        is_maximizer_starting = False
        leaf_node_values = generate_leaf_nodes()
        game_outcome = a_b_prun(leaf_node_values, 0, 0, is_maximizer_starting, float('-inf'), float('inf'))
        game_results.append(game_outcome)
    else:
        is_maximizer_starting = True
        leaf_node_values = generate_leaf_nodes()
        game_outcome = a_b_prun(leaf_node_values, 0, 0, is_maximizer_starting, float('-inf'), float('inf'))
        game_results.append(game_outcome)

<a name="1"></a><font color="#00FF00"><a href="match202-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

scorpion_wins = game_results.count(-1)
subzero_wins = game_results.count(1)

if scorpion_wins &gt; subzero_wins:
    print("Game Winner: Scorpion")
elif subzero_wins &gt; scorpion_wins:
    print("Game Winner: Sub-Zero")
else:
    print("The game ends with tie!!!")
</font>
print("Total Rounds Played:", rounds_to_play)

for round_num, result in enumerate(game_results):
    if result == -1:
      print(f"Winner of Round {round_num + 1}: Scorpion")
    else:
        print(f"Winner of Round {round_num + 1}: Sub-Zero")

"""**Part 2**"""

#Task-02:

def a_b_prun(n_vals, current_dpth, n_index, is_maxi, alfa, bita):

    if current_dpth == tree_dpth :
        return n_vals[n_index]

    if is_maxi:
        maxi_evalu = float('-inf')
        for p in range(2):
            eval = a_b_prun(n_vals, current_dpth + 1, n_index * 2 + p, False, alfa, bita)
            maxi_evalu = max(maxi_evalu, eval)
            alfa = max(alfa, eval)
            if bita &lt;= alfa:
                break
        return maxi_evalu
    else:
        mini_evalu = float('inf')
        for q in range(2):
            eval = a_b_prun(n_vals, current_dpth + 1, n_index * 2 + q, True, alfa, bita)
            mini_evalu = min(mini_evalu, eval)
            bita = min(bita, eval)
            if bita &lt;= alfa:
                break
        return mini_evalu


special_power_cost = int(input("Enter the cost for special power: "))

def pacmen_strategy(c) :

    # Given_in_Ques
    global n_vals, tree_dpth
    n_vals = [3, 6, 2, 3, 7, 1, 2, 0]
    tree_dpth = 3

    # Without_using_special_power
    normal_value = a_b_prun(n_vals, 0, 0, True , float('-inf'), float('inf'))

    # Applying special power
    max_power_value = max(n_vals)

    adjusted_special_power = max_power_value - c

    if normal_value &gt;= adjusted_special_power :
        return f"The minimax value is {normal_value}. Pacman does not use dark magic"

    else :
        # Pacmen chooses to use special power
        print(f"The new minimax value is {adjusted_special_power}.",end=" ")
        left_subtree_max = max(n_vals[0:4])
        right_subtree_max = max(n_vals[4:8])
        if left_subtree_max &gt;= right_subtree_max :
            return f"Pacmen goes left and uses dark magic"
        else :
            return f"Pacmen goes right and uses dark magic"

print(pacmen_strategy(special_power_cost))</pre>
</body>
</html>
