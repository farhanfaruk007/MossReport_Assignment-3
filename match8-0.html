<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/1/22301552_Maliha_Binte_Mohsin_Moumita_01_-_MALIHA_BINTE_MOHSIN_MOUMITA.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/1/22301552_Maliha_Binte_Mohsin_Moumita_01_-_MALIHA_BINTE_MOHSIN_MOUMITA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22301552_Maliha_Binte_Mohsin_Moumita_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_YSzqUsJvOid9og4E8r9d_N0b4iJeklf

# ***Part 1***
"""

<a name="0"></a><font color="#FF0000"><a href="match8-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_14.gif"/></a>

import random
from math import inf

def generateGameTree(depth):
    level_count, total_nodes = 0, 0

    while level_count &lt; depth:
        total_nodes += 2**level_count
        level_count += 1

    tree = [0] * (1 + total_nodes)

    leaf_start = 1
    for i in range(1, depth - 1):
        leaf_start = 2 * leaf_start + 1

    leaf_start += 1

    for i in range(leaf_start, len(tree)):
        tree[i] = random.choice([-1, 1])

    current_level = 0
    level_count = 1
    node_start = 1
    while current_level &lt; depth - 1:

        for i in range(node_start, 2**current_level + node_start):
            level_count = i
            tree[i] = [tree[i], current_level, -inf, inf]

        node_start = level_count + 1
        current_level += 1

    return tree


def maxPlayer(nodes, idx, alpha, beta):
    if isinstance(nodes[idx], int):
        return nodes[idx]
</font>
    best_value = -inf
<a name="3"></a><font color="#00FFFF"><a href="match8-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

    for i in range(2 * idx, 2 * idx + 2):
        new_value = minPlayer(nodes, i, alpha, beta)
        if new_value &gt; best_value:
            best_value = new_value
            nodes[idx][0] = new_value
        if new_value &gt;= beta:
            return best_value
        if new_value &gt; alpha:
            nodes[idx][2] = new_value

    return nodes[idx][0]


def minPlayer(nodes, idx, alpha, beta):
</font>    if isinstance(nodes[idx], int):
        return nodes[idx]

    best_value = inf
<a name="4"></a><font color="#FF00FF"><a href="match8-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

    for i in range(2 * idx, 2 * idx + 2):
        new_value = maxPlayer(nodes, i, alpha, beta)
        if new_value &lt; best_value:
            best_value = new_value
            nodes[idx][0] = new_value
        if new_value &lt;= alpha:
            return best_value
        if new_value &lt; beta:
            nodes[idx][3] = new_value

    return nodes[idx][0]


def alphaBetaMaximizing(nodes, idx):
</font>    return maxPlayer(nodes, idx, nodes[idx][2], nodes[idx][3])


def alphaBetaMinimizing(nodes, idx):
    return minPlayer(nodes, idx, nodes[idx][2], nodes[idx][3])


<a name="2"></a><font color="#0000FF"><a href="match8-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_12.gif"/></a>

def tournament(character_choice):
    if character_choice == 0:
        first_round = generateGameTree(5)
        first_winner = alphaBetaMaximizing(first_round, 1)

        second_round = generateGameTree(5)
        second_winner = alphaBetaMinimizing(second_round, 1)

        if first_winner != second_winner:
            third_round = generateGameTree(5)
            third_winner = alphaBetaMinimizing(third_round, 1)
            showResults([first_winner, second_winner, third_winner])
        else:
            showResults([first_winner, second_winner])

    else:
        first_round = generateGameTree(5)
        first_winner = alphaBetaMinimizing(first_round, 1)

        second_round = generateGameTree(5)
        second_winner = alphaBetaMaximizing(second_round, 1)

        if first_winner != second_winner:
            third_round = generateGameTree(5)
            third_winner = alphaBetaMaximizing(third_round, 1)
            showResults([first_winner, second_winner, third_winner])
        else:
            showResults([first_winner, second_winner])


def showResults(winners):
    winner_names = {1: "Sub-Zero", -1: "Scorpion"}
    if winners.count(1) &gt;= 2:
        print(f"Overall winner: {winner_names[1]}")
    else:
        print(f"Overall winner: {winner_names[-1]}")

    print(f"Total Matches Played: {len(winners)}")

    for idx, winner in enumerate(winners):
</font>        print(f"Winner of Match {idx + 1}: {winner_names[winner]}")


player_input = int(input("Choose your character (0 for Sub-Zero, 1 for Scorpion): "))
tournament(player_input)

"""# ***Part 2***"""

from math import inf

def createGameTree(depth):
    current_level, totalNodes = 0, 0

    while current_level &lt; depth:
        totalNodes += 2**current_level
        current_level += 1

    treeNodes = [0] * (1 + totalNodes)

    leafNodeStart = 1
    for i in range(1, depth - 1):
        leafNodeStart = 2 * leafNodeStart + 1

    leafNodeStart += 1

    level = 0
    current_level = 1
    nodeStart = 1
    while level &lt; depth - 1:

        for i in range(nodeStart, 2**level + nodeStart):
            current_level = i
            treeNodes[i] = [treeNodes[i], level, -inf, inf]

        nodeStart = current_level + 1
        level += 1

    return treeNodes


def maximizeNode(treeNodes, idx, alpha, beta):
    if isinstance(treeNodes[idx], int):
        return treeNodes[idx]

    max_value = -inf
<a name="5"></a><font color="#FF0000"><a href="match8-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

    for i in range(2 * idx, 2 * idx + 2):
        new_value = minimizeNode(treeNodes, i, alpha, beta)
        if new_value &gt; max_value:
            max_value = new_value
            treeNodes[idx][0] = new_value
        if new_value &gt;= beta:
            return max_value
</font>        if new_value &gt; alpha:
            treeNodes[idx][2] = new_value

    return treeNodes[idx][0]


def minimizeNode(treeNodes, idx, alpha, beta):
    if isinstance(treeNodes[idx], int):
        return treeNodes[idx]

    min_value = inf
    for i in range(2 * idx, 2 * idx + 2):
        new_value = maximizeNode(treeNodes, i, alpha, beta)
        if new_value &lt; min_value:
            min_value = new_value
            treeNodes[idx][0] = new_value
        if new_value &lt;= alpha:
            return min_value
        if new_value &lt; beta:
            treeNodes[idx][3] = new_value

    return treeNodes[idx][0]


def maximizeWithCost(treeNodes, idx, alpha, beta):
    if isinstance(treeNodes[idx], int):
        return treeNodes[idx]

    max_value = -inf
    for i in range(2 * idx, 2 * idx + 2):
        new_value = maximizeWithCost(treeNodes, i, alpha, beta)
        if new_value &gt; max_value:
            max_value = new_value
            treeNodes[idx][0] = new_value
        if new_value &gt;= beta:
            return max_value
<a name="1"></a><font color="#00FF00"><a href="match8-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_13.gif"/></a>

        if new_value &gt; alpha:
            treeNodes[idx][2] = new_value

    return treeNodes[idx][0]


def pacmanDecision(treeNodes, idx, cost):
    minimax_value = alphaBetaPruning(treeNodes, idx)
    max_with_cost = maximizeWithCost(treeNodes, idx, treeNodes[idx][2], treeNodes[idx][3])

    max_with_cost -= cost

    if minimax_value &gt;= max_with_cost:
        print(f"The minimax value is {minimax_value}. Pacman does not use dark magic")
    else:
        print(f"The new minimax value is {max_with_cost}.  Pacman goes right and uses dark magic")


def alphaBetaPruning(treeNodes, idx):
    value = maximizeNode(treeNodes, idx, treeNodes[idx][2], treeNodes[idx][3])
    return value


gameTree = createGameTree(4)

## hardcoding leaf node values ##
leafValues = [3, 6, 2, 3, 7, 1, 2, 0]

for i in range(len(leafValues)):
    gameTree[8 + i] = leafValues[i]


gameTreeCopy = gameTree[:]

cost_input = int(input("Input cost value: "))
pacmanDecision(gameTreeCopy, 1, cost_input)</font></pre>
</body>
</html>
