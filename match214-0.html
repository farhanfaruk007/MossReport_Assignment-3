<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/1/21201514_ILHANBINAHSAN_1_-_ILHAN_BIN_AHSAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/1/21201514_ILHANBINAHSAN_1_-_ILHAN_BIN_AHSAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201514_IlhanBinAhsan_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13J091F1kal86PjJvSYDvmjy36ug5eKlP
"""

#Task1
import random

def alpha_beta_pruning(depth, childNodePos, maximizer, uVal, alpha, beta):

    if depth == 3:

        return uVal[childNodePos]



    if maximizer:

        maxVal = float('-inf')

        for i in range(2):

            score = alpha_beta_pruning(depth + 1, childNodePos * 2 + i, False, uVal, alpha, beta)

            maxVal = max(maxVal, score)

            alpha = max(alpha, score)

            if alpha &gt;= beta:

                break

        return maxVal

    else:

        minVal = float('inf')

        for i in range(2):

            score = alpha_beta_pruning(depth + 1, childNodePos * 2 + i, True, uVal, alpha, beta)

            minVal = min(minVal, score)

            beta = min(beta, score)

            if alpha &gt;= beta:

                break

        return minVal



def mortalKombatGame(a):







    uV=[]

    for u in range(16):

      uV.append(random.randint(-1, 1))

    print(uV)



<a name="1"></a><font color="#00FF00"><a href="match214-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

    round_winners = []

    numberOfRounds = 3



    recentPlayer = a



    for round_num in range(numberOfRounds):

        winningRoundScore = alpha_beta_pruning(0, 0, recentPlayer == 1, uV, float('-inf'), float('inf'))
</font>
        if (winningRoundScore == 1):

          round_winner = "Sub-Zero"

        else:

           round_winner="Scorpion"

        round_winners.append(round_winner)

        if recentPlayer == 0:

          recentPlayer = 1

        else:

           recentPlayer = 0



    return round_winners





<a name="2"></a><font color="#0000FF"><a href="match214-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

round_winners = mortalKombatGame(int(input()))



champion = round_winners[-1]



print(f"Game Winner: {champion}")

print(f"Total Rounds Played: {len(round_winners)}")



for i, winner in enumerate(round_winners, 1):

    print(f"Winner of Round {i}: {winner}")
</font>


#Task2

# Function to compute minimax value with alpha-beta pruning

def minimax(node, depth, pacTurn, alpha, beta, uVal):

    # Base case: If we reach the leaf node

    if depth == 3:

        return uVal[node]



    if pacTurn:

        # Pacman maximizes the score

        maxVal = float('-inf')

        for i in range(2):

<a name="3"></a><font color="#00FFFF"><a href="match214-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

            score = minimax(2 * node + i, depth + 1, False, alpha, beta, uVal)

            maxVal = max(maxVal, score)

            alpha = max(alpha, score)

            if alpha &gt;= beta:

                break  # Alpha-beta pruning

        return maxVal

    else:

        # Ghost minimizes the score

        minVal = float('inf')
</font>
        for i in range(2):

            score = minimax(2 * node + i, depth + 1, True, alpha, beta, uVal)

            minVal = min(minVal, score)

            beta = min(beta, score)

            if alpha &gt;= beta:

                break  # Alpha-beta pruning

        return minVal



# Function to compute the best move considering dark magic

def pacman_game(c):

<a name="0"></a><font color="#FF0000"><a href="match214-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

    uVal = [3, 6, 2, 3, 7, 1, 2, 0]



    # Get the minimax value without using dark magic

    minimax_value = minimax(0, 0, True, float('-inf'), float('inf'), uVal)



    # Now calculate the value if Pacman uses dark magic on both subtrees

    # Left subtree with dark magic

    left_subtree_value = max(uVal[0], uVal[1]) - c



    # Right subtree with dark magic

    right_subtree_value = max(uVal[4], uVal[5]) - c
</font>


    # Compare outcomes

    if not(right_subtree_value&gt;=left_subtree_value):



        valWithDarkMagic = left_subtree_value

        direction = "left"

    else:

        valWithDarkMagic = right_subtree_value

        direction = "right"



    # Decide whether to use dark magic or not

    if valWithDarkMagic &gt; minimax_value:

        print(f"The new minimax value is {valWithDarkMagic}. Pacman goes {direction} and uses dark magic.")

    else:

        print(f"The minimax value is {minimax_value}. Pacman does not use dark magic.")





a=input("Enter the cost")



pacman_game(c=int(a))</pre>
</body>
</html>
