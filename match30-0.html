<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/24141238_Muhammed_Irtiza_Mahmood_cse422_08_lab_assignment03_-_MUHAMMED_IRTIZA_MAHMOOD.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/24141238_Muhammed_Irtiza_Mahmood_cse422_08_lab_assignment03_-_MUHAMMED_IRTIZA_MAHMOOD.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24141238_Muhammed Irtiza Mahmood_CSE422_08_Lab_Assignment03_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bxgf6p7XTTUVX3Gfsg9BbyKxnI6TueOr
<a name="1"></a><font color="#00FF00"><a href="match30-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_22.gif"/></a>

"""

#Task1:
import random
max_depth=5
branching_factor=2

def alpha_beta_search(state, depth, alpha, beta, max_player):
    if depth==0 or is_terminal(state):
        return evaluate(state)

    if max_player:
        var=-float('inf')
        for x in range(branching_factor):
            child=finalC(state, x)
            var = max(var,alpha_beta_search(child,depth-1,alpha,beta,False))
            alpha = max(alpha, var)
            if beta &lt;= alpha:
                break
        return var

    else:
        var=float('inf')
        for x in range(branching_factor):
            child=finalC(state, x)
            var=min(var,alpha_beta_search(child,depth-1,alpha,beta,True))
            beta=min(beta,var)
            if beta&lt;=alpha:
                break
        return var

def is_terminal(state):
    return get_depth(state)==max_depth

def evaluate(state):
</font>    if state%2==0:
        return -1
    else:
        return 1

<a name="2"></a><font color="#0000FF"><a href="match30-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

def finalC(state,act):
    return state*branching_factor+act+1

def get_depth(state):
    return len(bin(state))-2

def simulate_game(startP):
    rounds=0
    sco_wins=0
    sub_wins=0
    currentP=startP
    round_results=[]
    while rounds&lt;3:
</font>        rounds=rounds+1
        if random.choice([0,1])==0:
            winner="Scorpion"
            sco_wins=sco_wins+1
        else:
            winner="Sub-Zero"
            sub_wins=sub_wins+1
<a name="0"></a><font color="#FF0000"><a href="match30-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_52.gif"/></a>

        round_results.append(f"Winner of Round {rounds}: {winner}")
        currentP=1-currentP

    if sco_wins&gt;sub_wins:
        game_winner="Scorpion"
    elif sub_wins&gt;sco_wins:
        game_winner="Sub-Zero"
    else:
        game_winner="Draw"
    return game_winner,rounds,round_results

def main():
    startP=None
    while startP not in ["0", "1"]:
        startP=input("Enter the starting player (0 for Scorpion, 1 for Sub-Zero): ")
    startP=int(startP)
    game_winner,total_rounds,round_results=simulate_game(startP)

    print(f"Game Winner: {game_winner}")
    print(f"Total Rounds Played: {total_rounds}")
    for result in round_results:
        print(result)

if __name__ == "__main__":
    main()

#Task2:
def pacman_game():
    c = int(input("Enter the cost of using dark magic (c): "))
    score=[3, 6, 2, 3, 7, 1, 2, 0]
    def alpha_beta(node, depth, alpha, beta, maximizing_player):
        if depth==0:
            return score[node]

        if maximizing_player:
            highest=float('-inf')
            st = 2*node
            end=st+2
            for i in range(st, end):
                eval=alpha_beta(i, depth - 1, alpha, beta, False)
                highest=max(highest, eval)
                alpha=max(alpha, eval)
                if beta&lt;=alpha:
                    break
            return highest

        else:
            low=float('inf')
            st = 2 * node
            end = st + 2
            for i in range(st, end):
                eval = alpha_beta(i, depth - 1, alpha, beta, True)
                low = min(low, eval)
                beta = min(beta, eval)
                if beta &lt;= alpha:
                    break
            return low

    root_value_without_magic = alpha_beta(0, 3, float('-inf'), float('inf'), True)
    scores_with_magic_left = [score - c for score in [score[0], score[1]]]  # Left
    scores_with_magic_right = [score - c for score in [score[4], score[5]]]  # Right

    max_left=max(scores_with_magic_left)
    max_right=max(scores_with_magic_right)
    with_magic=max(max_left, max_right)

    if with_magic&gt;root_value_without_magic:
        if max_left&gt;max_right:
            print(f"The new minimax value is {max_left}. Pacman goes left and uses dark magic")
        else:
            print(f"The new minimax value is {max_right}. Pacman goes right and uses dark magic")
    else:
</font>        print(f"The minimax value is {root_value_without_magic}. Pacman does not use dark magic")
pacman_game()</pre>
</body>
</html>
