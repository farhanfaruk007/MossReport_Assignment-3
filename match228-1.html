<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/10/21301725_cse422_section10_labassignment3_-_MD.FARHAN_KABIR_MAZUMDER.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/14/21301689_cse422_section_labassignment3_-_KHAN_MOHAMMAD_AL_KAREEB.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301689_CSE422_Section_LabAssignment3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MufANi4eIp-yYnlb3tscpipEUW6rcxJ2
"""

import random

<a name="0"></a><font color="#FF0000"><a href="match228-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

def minimax_game_search(depth, node_index, game_scores, is_maximizer, upper_bound, lower_bound):
    if depth == 3:
        return game_scores[node_index]

    if is_maximizer:
        max_score = float('-inf')
        counter = 0
        while counter &lt; 2:
            current_value = minimax_game_search(depth + 1, node_index * 2 + counter,
                                              game_scores, False, upper_bound, lower_bound)
            max_score = max(max_score, current_value)
            lower_bound = max(lower_bound, max_score)
</font>            if upper_bound &lt;= lower_bound:
                break
            counter += 1
        return max_score
<a name="1"></a><font color="#00FF00"><a href="match228-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

    else:
        min_score = float('inf')
        counter = 0
        while counter &lt; 2:
            current_value = minimax_game_search(depth + 1, node_index * 2 + counter,
                                              game_scores, True, upper_bound, lower_bound)
            min_score = min(min_score, current_value)
            upper_bound = min(upper_bound, min_score)
</font>            if upper_bound &lt;= lower_bound:
                break
            counter += 1
        return min_score

def battle_simulation(starting_fighter):
    score_sequence = [random.choice([-1, 1]) for _ in range(8)]
    optimal_outcome = minimax_game_search(0, 0, score_sequence, starting_fighter == 1,
                                        float('inf'), float('-inf'))
    victor = "Sub-Zero" if optimal_outcome == 1 else "Scorpion"

    match_history = []
    current_fighter = starting_fighter
    round_count = 0

    while round_count &lt; 3:
        round_winner = "Sub-Zero" if random.random() &gt; 0.5 else "Scorpion"
        match_history.append(round_winner)
        current_fighter = 1 - current_fighter
        round_count += 1

    return victor, match_history

print("Mortal Kombat Game")
print()
starting_fighter = int(input("Enter starting player Number: "))
print()
tournament_winner, round_results = battle_simulation(starting_fighter)

print(f"Game win: {tournament_winner}")
print()
print(f"Total rounds Played: {len(round_results)}")
print()

for round_num in range(len(round_results)):
    print(f"win of Round {round_num}: {round_results[round_num]}")
    print()

# Task 2

import math

<a name="2"></a><font color="#0000FF"><a href="match228-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

def minimax_strategy(current_depth, position, maximize_turn, game_state, max_limit, min_limit):
    if current_depth == 3:
        return game_state[position]

    if maximize_turn:
        optimal_score = float('-inf')
        move_index = 0
        while move_index &lt; 2:
            current_score = minimax_strategy(current_depth + 1,
</font>                                          position * 2 + move_index,
                                          False,
                                          game_state,
                                          max_limit,
                                          min_limit)
            optimal_score = max(optimal_score, current_score)
            min_limit = max(min_limit, optimal_score)
            if max_limit &lt;= min_limit:
                break
            move_index += 1
        return optimal_score
    else:
        optimal_score = float('inf')
        move_index = 0
        while move_index &lt; 2:
            current_score = minimax_strategy(current_depth + 1,
                                          position * 2 + move_index,
                                          True,
                                          game_state,
                                          max_limit,
                                          min_limit)
            optimal_score = min(optimal_score, current_score)
            max_limit = min(max_limit, optimal_score)
            if max_limit &lt;= min_limit:
                break
            move_index += 1
        return optimal_score

def evaluate_pacman_moves(magic_cost):
    game_state = [3, 6, 2, 3, 7, 1, 2, 0]

    standard_move = minimax_strategy(0, 0, True, game_state,
                                   float('-inf'), float('inf'))

    left_path_value = max(game_state[1], game_state[2]) - magic_cost
    right_path_value = max(game_state[4], game_state[6]) - magic_cost

    if max(left_path_value, right_path_value) &gt; standard_move:
        if left_path_value &gt; right_path_value:
            return f"The new minimax value is {left_path_value}. Pacman goes left and uses dark magic"
        else:
            return f"The new minimax value is {right_path_value}. Pacman goes right and uses dark magic"
    else:
        return f"The minimax value is {standard_move}. Pacman does not use dark magic"

# Main execution
print(evaluate_pacman_moves(int(input("Enter the C value Number:  "))))</pre>
</body>
</html>
