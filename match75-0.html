<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/3/22101461_zayed_masum_cse422_03_lab_assignment03_fall2024_-_ZAYED_MASUM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/3/22101461_zayed_masum_cse422_03_lab_assignment03_fall2024_-_ZAYED_MASUM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101461_ZAYED MASUM_CSE422_03_Lab_Assignment03_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16MYmkeJ10SNyVQfYr9J6OnyEDD-1Ce28
"""

###01

import random

<a name="3"></a><font color="#00FFFF"><a href="match75-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

bf = 2
dp = 4
leaf_nodes_number = bf**dp

def leaf_node_genration():
    li = []
    for x in range(leaf_nodes_number) :
        p = random.choice([-1,1])
        li.append(p)
    return li

start = int(input("Enter which player will start first: "))
</font>if start == 1 :
    start = True
elif start == 0 :
    start = False
else :
    print("Wrong input. TRY again!")

game_round = 3

def alpha_beta_pruning(node_values, depth, index, maximizing_player, alpha, beta):
<a name="4"></a><font color="#FF00FF"><a href="match75-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

    if depth == dp :
        return node_values[index]
    if maximizing_player:
        max_eval = float('-inf')
        for i in range(2):
            eval = alpha_beta_pruning(node_values, depth + 1, index * 2 + i, False, alpha, beta)
</font>            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
<a name="5"></a><font color="#FF0000"><a href="match75-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

                break
        return max_eval
    else:
        min_eval = float('inf')
        for i in range(2):
            eval = alpha_beta_pruning(node_values, depth + 1, index * 2 + i, True, alpha, beta)
</font><a name="1"></a><font color="#00FF00"><a href="match75-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break
        return min_eval

winner = []
for i in range(game_round) :

    if i == 0 :
        node_values = leaf_node_genration()
        minimax_abp = alpha_beta_pruning(node_values, 0, 0, start , float('-inf'), float('inf'))
        winner.append(minimax_abp)
</font>    elif start == True :
        start = False
        node_values = leaf_node_genration()
        minimax_abp = alpha_beta_pruning(node_values, 0, 0, start , float('-inf'), float('inf'))
        winner.append(minimax_abp)
    elif start == False :
<a name="2"></a><font color="#0000FF"><a href="match75-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

        start = True
        node_values = leaf_node_genration()
        minimax_abp = alpha_beta_pruning(node_values, 0, 0, start , float('-inf'), float('inf'))
        winner.append(minimax_abp)

scorpion = winner.count(-1)
subzero = winner.count(1)
if scorpion &gt; subzero :
    print("Game Winner: Scorpion")
elif subzero &gt; scorpion :
    print("Game Winner: Sub-Zero")
else :
    print("GAME DRAW!")
print("Total Rounds Played:",game_round)
</font>for i in range(len(winner)) :
    if winner[i] == -1 :
        print(f"Winner of Round {i+1}: Scorpion")
    else :
        print(f"Winner of Round {i+1}: Sub-Zero")

### 02
def alpha_beta_pruning(node_values, depth, index, maximizing_player, alpha, beta):

    if depth == dp :
        return node_values[index]

    if maximizing_player:
        max_eval = float('-inf')
        for i in range(2):
            eval = alpha_beta_pruning(node_values, depth + 1, index * 2 + i, False, alpha, beta)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for i in range(2):
            eval = alpha_beta_pruning(node_values, depth + 1, index * 2 + i, True, alpha, beta)
<a name="0"></a><font color="#FF0000"><a href="match75-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_19.gif"/></a>

            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break
        return min_eval


## Magic cost
magic_cost = int(input("Enter Magic cost: "))

def pacman_game(c) :
    ## Question Given
    global node_values,dp
    node_values = [3, 6, 2, 3, 7, 1, 2, 0]
    dp = 3
    ## Without Magic
    without_magic_val = alpha_beta_pruning(node_values, 0, 0, True , float('-inf'), float('inf'))
    ## Magic applied
    max_val_magic = max(node_values)

    magic_final_val = max_val_magic - c
    if without_magic_val &gt;= magic_final_val :
        return f"The minimax value is {without_magic_val}. Pacman does not use dark magic"
    else :
        ## Pac man will use dark magic
        print(f"The new minimax value is {magic_final_val}.",end=" ")
        left = max(node_values[0:4])
        right = max(node_values[4:8])
        if left &gt;= right :
            return f"Pacman goes left and uses dark magic"
        else :
            return f"Pacman goes right and uses dark magic"
</font>
print(pacman_game(magic_cost))</pre>
</body>
</html>
