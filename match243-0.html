<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/22101281_sadia_cse422_07_assignment3_fall2024_-_MOST._SADIA_SULTANA_TAMIM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/22101281_sadia_cse422_07_assignment3_fall2024_-_MOST._SADIA_SULTANA_TAMIM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101281_Sadia_CSE422_07_Assignment3_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NIEqr9PoYnV6xtTVQaQIREWvnjDEe3nr
"""

import random
class mortalKombat:
    def __init__(self, strt_one,round_num):
        self.strt_one = strt_one
        self.playing_r = round_num
        self.max_depth = 5              #max depth of the game tree = 5
        self.branching_factor = 2       #branching factor = 2
        self.winner = []
        self.scorpion = 0 #Counting scorpion win
        self.subZero = 0 #Counting sub Zero win

    def gameStart(self):
        present_playing = self.strt_one

        for i in range(0, self.playing_r):
            r_winner = self.alpha_beta(present_playing, 0, -float('inf'), float('inf'))
            if r_winner == -1:
                self.winner.append('Scorpion')
                self.scorpion += 1
            else:
                self.winner.append('Sub-Zero')
                self.subZero += 1

            if self.scorpion == 2 or self.subZero == 2: # who will win atleast 2 match, will be the winner
                break

            present_playing = 1 - present_playing #The player who didn't take the first turn in the previous round will start in subsequent rounds.


        if self.scorpion &gt; self.subZero:
            game_winner = 'Scorpion'
        else:
            game_winner ='Sub-Zero'

        each_r_winner=""
        for i in range (len(self.winner)):
          each_r_winner += f"\nWinner of Round {i+1}: {self.winner[i]}"

        return game_winner, len(self.winner),each_r_winner


    def alpha_beta(self, player, dep, alpha, beta):
        if dep == self.max_depth:
            return random.choice([-1, 1])  # -1 means Scorpion wins, 1 means Sub-Zero wins

        if player == 0:  # Scorpion's turn--&gt;minimizing
            node = float('inf')
            for i in range(self.branching_factor):
                node = min(node, self.alpha_beta(1 - player, dep + 1, alpha, beta))
                beta = min(beta, node)
                if alpha &gt;= beta:
                    break  # Deleting Branch
            return node

        elif player == 1:  # Sub-Zero's turn--&gt;maximizing
            node = -float('inf')
            for i in range(self.branching_factor):
                node = max(node, self.alpha_beta(1 - player, dep + 1, alpha, beta))
                alpha = max(alpha, node)
                if alpha &gt;= beta:
                    break  # Deleting Branch
            return node


Starting = int(input("Enter starting player: "))
round_num= 3 #int(input("Number of total Rounds to be Playedr: "))  #Let, Total Rounds Played = 3. He, who will win atleast 2 match will be the winner

game = mortalKombat(Starting , round_num)

game_winner, total_rounds_played, each_r_winner = game.gameStart()

print(f"Game Winner: {game_winner} \nTotal Rounds Played: {total_rounds_played} {each_r_winner}")

def pacman_game(c):
    list_of_leaf = [3, 6, 2, 3, 7, 1, 2, 0]
    L_magic_of_dark = max(list_of_leaf[0:4]) - c
    R_magic_of_dark = max(list_of_leaf[4:8]) - c

    if L_magic_of_dark &gt; R_magic_of_dark :
        magic_of_dark = L_magic_of_dark
        pass_by = "left"
    else:
        magic_of_dark = R_magic_of_dark
        pass_by = "right"
    alpha = float('-inf')
    beta = float('inf')
    no_magic_of_dark = beta_alpha(0, 0, 0, alpha, beta, list_of_leaf)

    if magic_of_dark &gt; no_magic_of_dark:
        return f"The new minimax value is {magic_of_dark}. Pacman goes {pass_by} and uses dark magic"
    else:
        return f"The minimax value is {no_magic_of_dark}. Pacman does not use dark magic"

<a name="0"></a><font color="#FF0000"><a href="match243-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_19.gif"/></a>

def beta_alpha(depth, scored, player, alpha, beta, leaf_values):
    if depth == 3:
        return leaf_values[scored]
    if player == 0:
        node = float('-inf')
        for i in range(2):
            node = max(node, beta_alpha(depth + 1, scored * 2 + i, 1, alpha, beta, leaf_values))
            alpha = max(alpha, node)
            if beta &lt;= alpha:  # Deleting Branch
                break
        return node
    elif player == 1:
        node = float('inf')
        for i in range(2):
            node = min(node, beta_alpha(depth + 1, scored * 2 + i, 0, alpha, beta, leaf_values))
            beta = min(beta, node)
            if beta &lt;= alpha:   # Deleting Branch
                break
        return node
</font>
strategy = pacman_game(2)
print(strategy)

strategy = pacman_game(5)
print(strategy)</pre>
</body>
</html>
