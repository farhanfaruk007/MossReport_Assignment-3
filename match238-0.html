<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/11/21301724_md_maruf_cse422_11_labassignment03_fall24_-_MD._MARUF.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/11/21301724_md_maruf_cse422_11_labassignment03_fall24_-_MD._MARUF.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301724_Md.Maruf_cse422_11_LabAssignment03_Fall24

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AJE-4m3vPVv9y7S0SakpQstaM--pxiQp
"""

#####__TASK_1__######

import random

class MKGame:
    def __init__(self, first_player):
        self.first_player = first_player
        self.round_results = []
        self.total_rounds = 0
        self.leaf_vals = self.create_leaf_nodes()

    def create_leaf_nodes(self):

        return [random.choice([-1, 1]) for _ in range(32)]  # randomly generate 32 leaf nodes value

    def ab_search(self, level, alpha, beta, is_maximizing):
        if level == 0:

            return self.leaf_vals[random.randint(0, len(self.leaf_vals) - 1)]

<a name="0"></a><font color="#FF0000"><a href="match238-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_14.gif"/></a>

        if is_maximizing == 0:  # for  scorpion's move
            max_val = float('-inf')
            for _ in range(2):  # two possible moves
                evaluation = self.ab_search(level - 1, alpha, beta, 1)
                max_val = max(max_val, evaluation)
                alpha = max(alpha, evaluation)
                if beta &lt;= alpha:
                    break
            return max_val
        else:  # Sub-Zero's move
            min_val = float('inf')
            for _ in range(2):  # two possible moves
                evaluation = self.ab_search(level - 1, alpha, beta, 0)
                min_val = min(min_val, evaluation)
                beta = min(beta, evaluation)
                if beta &lt;= alpha:
                    break
            return min_val

    def start_game(self):
</font>        current_player = self.first_player
        for round_num in range(1, 4):  # game simulate korbe 3 bar
            self.total_rounds += 1
            outcome = self.ab_search(5, float('-inf'), float('inf'), current_player)
            if outcome == -1:
                winner = "Scorpion"
            else:
                winner = "Sub-Zero"
            self.round_results.append(winner)
            current_player = 1 - current_player  # player change korbo next roud er jnno

    def show_results(self):
<a name="1"></a><font color="#00FF00"><a href="match238-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

        overall_winner = "Scorpion" if self.round_results.count("Scorpion") &gt; self.round_results.count("Sub-Zero") else "Sub-Zero"
        print(f"Game Winner: {overall_winner}")
        print(f"Total Rounds Played: {self.total_rounds}")
        for i, winner in enumerate(self.round_results, start=1):
</font>            print(f"Winner of Round {i}: {winner}")
        print("Leaf nodes utility values:", self.leaf_vals)

if __name__ == "__main__":
    first_player = input("Enter first player (0 for scorpion, 1 for sub-zero): ")

    # Ensure the input is valid
    if first_player == '0' or first_player == '1':
        game = MKGame(int(first_player))
        game.start_game()
        game.show_results()
    else:
        print("Invalid input. please enter 0 for scorpion or 1 for sub-zero.")



#####__TASK_2__######



def pacman_game(c):
    scores = [3, 6, 2, 3, 7, 1, 2, 0]   #leaf node

    left_subtree = scores[0:4]
    right_subtree = scores[4:8]

    max_left = max(left_subtree)  # max of L sub
    max_right = max(right_subtree)  # max of R sub

                                        # calculate values when using dark magic
    left_with_magic = max_left - c
    right_with_magic = max_right - c


    def alpha_beta(d, a, b, maximizing):              # alpha-beta for minimax
        if d == 0:
            return scores[0]

        if maximizing:
            best = float('-inf')
            for _ in range(2):
                result = alpha_beta(d - 1, a, b, False)
                best = max(best, result)
                a = max(a, result)
                if b &lt;= a:
                    break  # beta cut
            return best
        else:
            best = float('inf')
            for _ in range(2):
                result = alpha_beta(d - 1, a, b, True)
                best = min(best, result)
                b = min(b, result)
                if b &lt;= a:
                    break  # al cut
            return best


    minimax_value = alpha_beta(3, float('-inf'), float('inf'), True)  # calculate alpha_b

                                         # Compare results
    if minimax_value &gt; left_with_magic and minimax_value &gt; right_with_magic:
        print(f"The minimax value is {minimax_value}. Pacman does not use dark magic")
    elif left_with_magic &gt; right_with_magic:
        print(f"The new minimax value is {left_with_magic}. Pacman goes left and uses dark magic")
    else:
        print(f"The new minimax value is {right_with_magic}. Pacman goes right and uses dark magic")



if __name__ == "__main__":
    valid_input = False
    while not valid_input:
        user_input = input("Let a cost : ")
        if user_input.isdigit():  # Check if the input is a positive integer
            user_input = int(user_input)
            valid_input = True
        else:
            print("enter a valid positive integer.")

    pacman_game(user_input)

</pre>
</body>
</html>
