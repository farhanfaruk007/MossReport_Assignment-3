<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/4/20301172_Md._Tazfiq_Khan_CSE422_04_Assignment03_Fall2024_-_MD._TAZFIQ_KHAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/4/20301172_Md._Tazfiq_Khan_CSE422_04_Assignment03_Fall2024_-_MD._TAZFIQ_KHAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""422_fall_lab3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DlD4q_zKW9TOM1UaPX0HMuMB-3HQEojr
<a name="1"></a><font color="#00FF00"><a href="match23-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

"""

#Part1
import random

class Node:
    def __init__(self, name, children=None, value=None):
        self.name = name
        self.children = children if children else []
        self.value = value


def alpha_beta_pruning(node, depth, alpha, beta, maximizing_player):
    if depth == 0 or not node.children:
        return node.value

    if maximizing_player:
        max_eval = float('-inf')
        for child in node.children:
</font>            eval = alpha_beta_pruning(child, depth - 1, alpha, beta, False)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for child in node.children:
            eval = alpha_beta_pruning(child, depth - 1, alpha, beta, True)
<a name="0"></a><font color="#FF0000"><a href="match23-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_59.gif"/></a>

            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break
        return min_eval


def build_game_tree(branching_factor, depth):

    leaf_values = [random.choice([-1, 1]) for _ in range(branching_factor ** depth)]
    #print(f"Leaf Values: {leaf_values}")


    leaves = [Node(f"L{i}", value=v) for i, v in enumerate(leaf_values)]


    current_level = leaves
    for d in range(depth - 1, 0, -1):
        next_level = [
            Node(f"N{d}_{i}", children=current_level[i * branching_factor:(i + 1) * branching_factor])
            for i in range(len(current_level) // branching_factor)
        ]
        current_level = next_level


    root = Node("Root", children=current_level)
    return root


def simulate_game(starting_player, branching_factor=2, depth=5, rounds_to_play=3):
    rounds = []
    current_player = starting_player

    for round_number in range(1, rounds_to_play + 1):

        root = build_game_tree(branching_factor, depth)
        alpha, beta = float('-inf'), float('inf')


        optimal_value = alpha_beta_pruning(root, depth, alpha, beta, current_player == 1)
        winner = "Scorpion" if optimal_value == -1 else "Sub-Zero"
        rounds.append((round_number, winner))


        current_player = 1 - current_player

    scor_win = 0
    sub_win = 0
    for r in rounds:
      if r[1] == "Scorpion":
        scor_win += 1
      else:
        sub_win += 1

    if scor_win &gt; sub_win:
      game_winner = "Scorpion"
    else:
      game_winner = "Sub_Zero"
    return game_winner, len(rounds), rounds



starting_player = int(input("Enter the starting player (0 for Scorpion, 1 for Sub-Zero): "))
game_winner, total_rounds, round_results = simulate_game(starting_player)

print(f"Game Winner: {game_winner}")
print(f"Total Rounds Played: {total_rounds}")
for round_number, winner in round_results:
    print(f"Winner of Round {round_number}: {winner}")

#Part2
def alpha_beta_pacman(node, depth, is_max, alpha, beta, values):
    if depth == 0:
        return values[node]

    if is_max:
        max_eval = float('-inf')
        for child in [2 * node, 2 * node + 1]:
            eval = alpha_beta_pacman(child, depth - 1, False, alpha, beta, values)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for child in [2 * node, 2 * node + 1]:
            eval = alpha_beta_pacman(child, depth - 1, True, alpha, beta, values)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
</font>            if beta &lt;= alpha:
                break
        return min_eval

def pacman_game(c):
<a name="2"></a><font color="#0000FF"><a href="match23-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

    values = [3, 6, 2, 3, 7, 1, 2, 0]
    root_value_without_magic = alpha_beta_pacman(0, 3, True, float('-inf'), float('inf'), values)

    left_subtree = max(values[0:4]) - c
    right_subtree = max(values[4:8]) - c

    if max(left_subtree, right_subtree) &gt; root_value_without_magic:
        best_move = "left" if left_subtree &gt;= right_subtree else "right"
        print(f"The new minimax value is {max(left_subtree, right_subtree)}. Pacman goes {best_move} and uses dark magic.")
    else:
        print(f"The minimax value is {root_value_without_magic}. Pacman does not use dark magic.")


pacman_game(2)
</font>pacman_game(5)</pre>
</body>
</html>
