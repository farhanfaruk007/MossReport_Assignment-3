<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/22101118_tanzim_hossain_safin_cse422_07_assignment03_fall2024_py_-_TANZIM_HOSSAIN_SAFIN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/22101118_tanzim_hossain_safin_cse422_07_assignment03_fall2024_py_-_TANZIM_HOSSAIN_SAFIN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101118_Tanzim_Hossain_safin_CSE422_07_Assignment03_Fall2024.py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zemig7DMgr1UCuHs7_S0n1O1-kbxYjeQ
"""

import random

class BattleSimulator:
<a name="0"></a><font color="#FF0000"><a href="match206-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

    def __init__(self, first_player):
        self.first_player = first_player  # 0 for Scorpion, 1 for Sub-Zero
        self.match_outcomes = []
        self.total_matches = 0

    def evaluate_move(self, depth, alpha, beta, is_max_turn):
        if depth == 5:  # Maximum depth reached
            return random.choice([-1, 1])  # Random outcome: -1 for Scorpion, 1 for Sub-Zero

        if is_max_turn:
            max_score = float("-inf")
            for _ in range(2):  # Two possible moves
                score = self.evaluate_move(depth + 1, alpha, beta, False)
                max_score = max(max_score, score)
</font>                alpha = max(alpha, score)
                if beta &lt;= alpha:
                    break  # Pruning
            return max_score
        else:
            min_score = float("inf")
            for _ in range(2):  # Two possible moves
                score = self.evaluate_move(depth + 1, alpha, beta, True)
                min_score = min(min_score, score)
                beta = min(beta, score)
                if beta &lt;= alpha:
                    break  # Pruning
            return min_score

    def conduct_battle(self):
        active_player = self.first_player
        for match in range(1, 4):  # Up to 3 matches
            self.total_matches += 1
            victor = self.evaluate_move(0, float("-inf"), float("inf"), active_player)
            if victor == -1:
                match_winner = "Scorpion"
            else:
                match_winner = "Sub-Zero"
            self.match_outcomes.append(match_winner)
            active_player = 1 - active_player  # Switch player

    def determine_winner(self):
        self.conduct_battle()
        if self.match_outcomes.count("Scorpion") &gt; self.match_outcomes.count("Sub-Zero"):
            overall_winner = "Scorpion"
        else:
            overall_winner = "Sub-Zero"
        return overall_winner, self.total_matches, self.match_outcomes


def minimax_algorithm(depth, node_idx, is_max_turn, values, alpha, beta):
    if depth == 3:  # Leaf node
        return values[node_idx]

    if is_max_turn:  # Pacman's turn
        best_value = float('-inf')
        for i in range(2):  # Two children
            value = minimax_algorithm(depth + 1, node_idx * 2 + i, False, values, alpha, beta)
            best_value = max(best_value, value)
            alpha = max(alpha, best_value)
            if beta &lt;= alpha:
                break  # Pruning
        return best_value
    else:  # Ghost's turn
        best_value = float('inf')
        for i in range(2):  # Two children
            value = minimax_algorithm(depth + 1, node_idx * 2 + i, True, values, alpha, beta)
            best_value = min(best_value, value)
            beta = min(beta, best_value)
<a name="1"></a><font color="#00FF00"><a href="match206-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

            if beta &lt;= alpha:
                break  # Pruning
        return best_value

def pacman_tactics(c):
    values = [3, 6, 2, 3, 7, 1, 2, 0]  # Scores at leaf nodes
    alpha = float('-inf')
    beta = float('inf')

    # Calculate minimax value without special powers
    minimax_value_no_magic = minimax_algorithm(0, 0, True, values, alpha, beta)

    # Calculate minimax values with special powers
    left_value_with_magic = max(values[:4]) - c  # Pacman goes left with special power
    right_value_with_magic = max(values[4:]) - c  # Pacman goes right with special power
</font>
    # Determine the best move with special powers
    best_with_magic = max(left_value_with_magic, right_value_with_magic)

    # Output results
    if best_with_magic &gt; minimax_value_no_magic:
        print(f"The new minimax value is {best_with_magic}. Pacman goes right and uses special power.")
    else:
        print(f"The minimax value is {minimax_value_no_magic}. Pacman does not use special power.")

# Task 1: Mortal Kombat Game
first_player = int(input("Enter starting player (0 for Scorpion, 1 for Sub-Zero): "))
battle_instance = BattleSimulator(first_player)
winner, total_matches, match_winners = battle_instance.determine_winner()

# Output the results
print(f"Game Winner: {winner}")
print(f"Total Matches Played: {total_matches}")
for i in range(total_matches):
    print(f"Winner of Match {i + 1}: {match_winners[i]}")

# Task 2: Pacman Game
pacman_tactics(2)
pacman_tactics(5)</pre>
</body>
</html>
