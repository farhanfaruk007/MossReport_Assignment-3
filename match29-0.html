<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/6/21101165_miftahul_jannat_orpi_cse422_06_assignment03_fall2024_-_MIFTAHUL_JANNAT_ORPI.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/6/21101165_miftahul_jannat_orpi_cse422_06_assignment03_fall2024_-_MIFTAHUL_JANNAT_ORPI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21101165_Miftahul Jannat Orpi_CSE422_06_Assignment03_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y0bleHt1xdBURMwgIgaDaxBTeXfnqJbe
<a name="0"></a><font color="#FF0000"><a href="match29-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_28.gif"/></a>

"""

# Task 1: Alpha-Beta Pruning Implementation
import random

def alpha_beta(node, depth, alpha, beta, is_maximizing, outcomes):
    if depth == 0 or node in outcomes:  # Checking terminal state or not
        return outcomes.get(node, 0)

    if is_maximizing:  # Maximizer er turn
        max_score = float('-inf')
        for child_node in generate_children(node):
            eval_score = alpha_beta(child_node, depth - 1, alpha, beta, False, outcomes)
            max_score = max(max_score, eval_score)
            alpha = max(alpha, eval_score)
            if beta &lt;= alpha:
                break  #A&amp;B Pruning
        return max_score
    else:  # Minimizer er turn
        min_score = float('inf')
        for child_node in generate_children(node):
            eval_score = alpha_beta(child_node, depth - 1, alpha, beta, True, outcomes)
            min_score = min(min_score, eval_score)
            beta = min(beta, eval_score)
            if beta &lt;= alpha:
                break  #A&amp;B Pruning
        return min_score

def generate_children(node):
    return [node * 2 + 1, node * 2 + 2]

class GameSimulation:
    def __init__(self, starting_player):
        self.starting_player = starting_player
        self.max_depth = 5
        self.outcomes = self.initialize_outcomes()
        self.results = []

    def initialize_outcomes(self):
        leaf_nodes = 2 ** self.max_depth
</font><a name="2"></a><font color="#0000FF"><a href="match29-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_17.gif"/></a>

        return {i: -1 if self.starting_player == 0 else 1 for i in range(leaf_nodes)}

    def simulate_round(self, current_player):
        root_node = 0
        is_maximizing = current_player == 1
        winner = alpha_beta(
            root_node, self.max_depth, float('-inf'), float('inf'), is_maximizing, self.outcomes
        )
        return "Scorpion" if winner == -1 else "Sub-Zero"

    def simulate_game(self):
        rounds = 3
        current_player = self.starting_player

        for _ in range(rounds):
            winner = self.simulate_round(current_player)
            self.results.append(winner)
            current_player = 1 - current_player

        scorpion_wins = self.results.count("Scorpion")
        subzero_wins = self.results.count("Sub-Zero")
        return ("Scorpion" if scorpion_wins &gt; subzero_wins else "Sub-Zero"), rounds, self.results

starting_player = int(input("Enter who starts first (0 for Scorpion, 1 for Sub-Zero): "))
</font>if starting_player not in (0, 1):
    raise ValueError("Invalid input! Enter 0 for Scorpion or 1 for Sub-Zero.")

<a name="3"></a><font color="#00FFFF"><a href="match29-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_10.gif"/></a>

game = GameSimulation(starting_player)
final_winner, total_rounds, results = game.simulate_game()

print(f"\nGame winner: {final_winner}")
print(f"Total rounds played: {total_rounds}")
for i, winner in enumerate(results, 1):
    print(f"Winner of round {i}: {winner}")

# Task 2: Pacman Game Strategy
class PacmanGame:
    def __init__(self, penalty):
        self.penalty = penalty
        self.leaf_nodes = [3, 6, 2, 3, 7, 1, 2, 0]

    def minimax(self, depth, node, is_maximizing):
</font>        if depth == 2:
            return self.leaf_nodes[node]

<a name="1"></a><font color="#00FF00"><a href="match29-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_23.gif"/></a>

        if node * 2 &gt;= len(self.leaf_nodes) or node * 2 + 1 &gt;= len(self.leaf_nodes):
            return self.leaf_nodes[node]  #making sure index jeno out of range na hoy

        if is_maximizing:
            return max(self.minimax(depth + 1, node * 2, False),
                       self.minimax(depth + 1, node * 2 + 1, False))
        else:
            return min(self.minimax(depth + 1, node * 2, True),
                       self.minimax(depth + 1, node * 2 + 1, True))

    def evaluate_strategy(self):
        no_magic_score = self.minimax(0, 0, True)
        left_magic_score = max(self.leaf_nodes[0], self.leaf_nodes[1]) - self.penalty
        right_magic_score = max(self.leaf_nodes[4], self.leaf_nodes[5]) - self.penalty

        if right_magic_score &gt; left_magic_score and right_magic_score &gt; no_magic_score:
            return right_magic_score, "Pacman goes right and uses dark magic"
        elif left_magic_score &gt; no_magic_score:
            return left_magic_score, "Pacman goes left and uses dark magic"
        else:
            return no_magic_score, "Pacman does not use dark magic"

def play_pacman():
    penalty = int(input("Enter penalty value: "))
</font>    if penalty &lt; 0:
        raise ValueError("Penalty must be a non-negative integer.")
    game = PacmanGame(penalty)
    score, strategy = game.evaluate_strategy()
    print(f"The minimax value is {score}. {strategy}")

play_pacman()</pre>
</body>
</html>
