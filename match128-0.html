<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/12/21201590_md_jadid_hossain_sanim_cse422_12_assignment03_fall2024_-_MD._JADID_HOSSAIN_SANIM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/12/21201590_md_jadid_hossain_sanim_cse422_12_assignment03_fall2024_-_MD._JADID_HOSSAIN_SANIM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201590_Md. Jadid Hossain Sanim_CSE422_12_Assignment03_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14fi_T65I7ysS_167pqyI_6A1rwkXdZrv
"""

#Mortal Kombat
from math import inf
result_tree = []
p_count = 0
bran_factor= 2
depth =5
rounds=3
while p_count &lt; (bran_factor**depth) :
  if p_count % 2 != 0:
    result_tree.append(-1)
  else:
    result_tree.append(1)
<a name="1"></a><font color="#00FF00"><a href="match128-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

  p_count += 1

def bestMove(tree_position, current_leaf, alpha_limit, beta_limit, is_max_turn):
    if current_leaf == 0:
        return result_tree[tree_position]
    if is_max_turn:
        highest_outcome = -inf
</font>        move_count = 0
        while move_count &lt;bran_factor:
<a name="2"></a><font color="#0000FF"><a href="match128-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

            evaluated_outcome = bestMove(tree_position * 2+move_count, current_leaf-1, alpha_limit, beta_limit, False)
            highest_outcome = max(highest_outcome, evaluated_outcome)
            alpha_limit = max(alpha_limit, highest_outcome)
            if beta_limit &lt;= alpha_limit:
                break
            move_count += 1
</font>        return highest_outcome
    else:
        lowest_outcome = inf
        move_count = 0
        while move_count &lt; bran_factor:
<a name="0"></a><font color="#FF0000"><a href="match128-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_28.gif"/></a>

            evaluated_outcome = bestMove(tree_position * 2+move_count, current_leaf-1, alpha_limit, beta_limit, True)
            lowest_outcome = min(lowest_outcome, evaluated_outcome)
            beta_limit = min(beta_limit, lowest_outcome)
            if beta_limit &lt;= alpha_limit:
                break
            move_count += 1
        return lowest_outcome


def gameSimulation(starting_turn):
    active_player = starting_turn
    rounds_completed = 0
    round_results = []
    scorpion_outcome = 0
    subzero_outcome = 0

    for current_round in range(rounds):
        round_outcome = bestMove(0, 5, float('-inf'), float('inf'), active_player == 1)
        if round_outcome == 1:
            subzero_outcome += 1
            round_results.append('Sub-Zero')
        else:
            scorpion_outcome += 1
            round_results.append('Scorpion')

        active_player = 1-active_player
        rounds_completed += 1


    final_winner = 'Sub-Zero' if subzero_outcome &gt; scorpion_outcome else 'Scorpion'
    return round_results, final_winner, rounds_completed

first_turn = int(input("Enter FIrst Player(0 for Scorpion, 1 for Sub-Zero): "))
round_history, match_winner, total_rounds_played = gameSimulation(first_turn)

output_message = f"""Match Winner: {match_winner}
Total Rounds Fought: {total_rounds_played}
"""
round_counter = 1
for victory in round_history:
    output_message += f"Winner of Round {round_counter}: {victory}\n"
    round_counter += 1

print(output_message)
</font>
#Games with Magic
leafNodes = [3, 6, 2, 3, 7, 1, 2, 0]
bran_factor= 2

def bestMove(tree_position, current_leaf, alpha_limit, beta_limit, is_max_turn):
    if current_leaf == 0:
        return leafNodes[tree_position]
    if is_max_turn:
        highest_outcome = -inf
        for move_count in range(bran_factor):
            evaluated_outcome = bestMove(tree_position *2+move_count, current_leaf-1, alpha_limit, beta_limit, False)
            highest_outcome = max(highest_outcome, evaluated_outcome)
            alpha_limit = max(alpha_limit, highest_outcome)
            if beta_limit &lt;= alpha_limit:
                break
        return highest_outcome
    else:
        lowest_outcome = inf
        for move_count in range(bran_factor):
            evaluated_outcome = bestMove(tree_position *2+move_count, current_leaf-1, alpha_limit, beta_limit, True)
            lowest_outcome = min(lowest_outcome, evaluated_outcome)
            beta_limit = min(beta_limit, lowest_outcome)
            if beta_limit &lt;= alpha_limit:
                break
        return lowest_outcome


def pacman_game(c):
    value_without_DM = bestMove(0, 3, float('-inf'), float('inf'), True)
    left_max = max(leafNodes[: len(leafNodes)//2])
    right_max = max(leafNodes[len(leafNodes)//2:])

    if (right_max - c) &gt; value_without_DM:
        print(f"The new minimax value is {right_max - c}. Pacman goes right and uses dark magic.")
        return
    if (left_max - c) &gt; value_without_DM:
        print(f"The new minimax value is {left_max - c}. Pacman goes left and uses dark magic.")
        return
    print(f"The minimax value is {value_without_DM}. Pacman does not use dark magic.")


darkMagic_value= int(input("The cost of the Dark Magic: "))
pacman_game(darkMagic_value)</pre>
</body>
</html>
