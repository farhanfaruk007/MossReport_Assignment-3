<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/1/22101531_rudabashehnum_sec01_cse422_-_RUDABA_SHEHNUM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/1/22101531_rudabashehnum_sec01_cse422_-_RUDABA_SHEHNUM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101531_RudabaShehnum_sec01_CSE422

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U10hgewUM6f8Ozwn_IZDdhtzQ64PVu4F
"""

def max_state(depth, alpha, beta):
    if depth == max_depth:
        return evaluate_final_state()

    highest_score = negative_infinity
    for i in range(branching_factor):
        state_value = min_state(depth + 1, alpha, beta)
        highest_score = max(highest_score, state_value)
        alpha = max(alpha, highest_score)
        if alpha &gt;= beta:
            break

    return highest_score


def evaluate_final_state():
    state_values = [-1, 1]
    return random.choice(state_values)


def min_state(depth, alpha, beta):
    if depth == max_depth:
        return evaluate_final_state()

    lowest_score = positive_infinity
    for i in range(branching_factor):
        state_value = max_state(depth + 1, alpha, beta)
        lowest_score = min(lowest_score, state_value)
        beta = min(beta, lowest_score)
        if alpha &gt;= beta:
            break

    return lowest_score


<a name="1"></a><font color="#00FF00"><a href="match6-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

def minimax(alpha=alpha_initial, beta=beta_initial, is_maxplayer =is_maximizing_player):
    depth = 0
    if is_maxplayer :
        return max_state(depth, alpha, beta)
    else:
        return min_state(depth, alpha, beta)

turn = int(input("Please press 0 or 1: "))
player1 = "Scorpion"
player2 = "Sub-Zero"
if turn:
    player1, player2 = player2, player1

round_winners = []
scores = {player1: 0, player2: 0}
round_number = 0

while round_number &lt; total_rounds:
    result = minimax()
    if result &gt; 0:
        round_winners.append(player1)
        scores[player1] += 1
    else:
        round_winners.append(player2)
        scores[player2] += 1


    player1, player2 = player2, player1

    if scores[player1] &gt; 1 or scores[player2] &gt; 1:
</font><a name="2"></a><font color="#0000FF"><a href="match6-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

        break
    round_number += 1

if scores[player1] &gt; scores[player2]:
    print(f"Game Winner: {player1}")
else:
    print(f"Game Winner: {player2}")

print(f"Total Rounds Played: {len(round_winners)}")
for round_index, winner in enumerate(round_winners, 1):
</font><a name="0"></a><font color="#FF0000"><a href="match6-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_60.gif"/></a>

    print(f"Winner of Round {round_index}: {winner}")

def dark_minimax(node, depth, alpha, beta, maxplayer , pruningTree, c):
  if depth == 0 :
    return pruningTree[node]
  if node &gt;= len(pruningTree):
    return pruningTree[node]

  if maxplayer !=False:
    maximum_value = -float("inf")
    i=0
    while i&lt;len(pruningTree[node]):

      obs = dark_minimax(pruningTree[node][i], depth - 1, alpha, beta, False, pruningTree, c)

      if maximum_value&gt;obs:
        pass
      else:
        maximum_value=obs
      if alpha&gt;obs:
        pass
      else:
        alpha=obs

      if beta &lt;= alpha:
        break
      i+=1
    return maximum_value
  else:
    maximum_value = -float("inf")
    i=0
    while i&lt;len(pruningTree[node]):

      obs = dark_minimax(pruningTree[node][i], depth - 1, alpha, beta, True, pruningTree, c)

      if maximum_value&gt;obs:
        pass
      else:
        maximum_value=obs

      if beta &lt;= alpha:
        break
      i+=1
    maximum_value = maximum_value - c
    return maximum_value

def minimax(node, depth, alpha, beta, maxplayer , pruningTree,c):
  if depth == 0 :
    return pruningTree[node]
  if node &gt;= len(pruningTree):
    return pruningTree[node]
  if maxplayer :
    maximum_value = -float("inf")
    i=0
    while i&lt;len(pruningTree[node]):

      obs = minimax(pruningTree[node][i], depth - 1, alpha, beta, False, pruningTree,c)
      if obs&gt;maximum_value:
        maximum_value=obs
      else:
        pass
      if alpha&gt;obs:
        pass
      else:
        alpha=obs

      if beta &lt; alpha or beta==alpha:
        break
      i+=1
    return maximum_value
  else:
    minobs = float("inf")
    i=0
    while i&lt;len(pruningTree[node]):

      obs = minimax(pruningTree[node][i], depth - 1, alpha, beta, True, pruningTree,c)
      if obs&lt;minobs:
        minobs=obs
      else:
        pass
      if beta&gt;obs:
        beta=obs
      else:
        pass

      if beta &lt; alpha or beta==alpha:
        break
      i+=1
    return minobs

def pacman_game(c):


  pruningTree = [ [1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14] ]
  x=[3, 6, 2, 3, 7, 1, 2, 0]
  pruningTree=pruningTree+x
  initial_depth = 3

  alpha = -float("inf")

  beta = float("inf")
  maxplayer  = True
  result = minimax(0, initial_depth, alpha, beta, maxplayer , pruningTree,c)

  maxplayer  = True
  darkMagicValue = dark_minimax(0, initial_depth, alpha, beta, maxplayer , pruningTree, c)

  if result&gt;darkMagicValue:
    print(f"The minimax value is ",result,". Pacman does not use dark magic")
  else:
    print(f"The new minimax value is ",darkMagicValue,". Pacman goes right and uses dark magic")
x=int(input("Please enter the cost: "))
pacman_game(x)
</font>
</pre>
</body>
</html>
