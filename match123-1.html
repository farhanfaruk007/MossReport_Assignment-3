<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/2/22299241_lab03_sec02_-_TASNIA_AHMED_CHOWDHURY.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/22101379_md_mozahedul_hoque_cse422_07_assignment03_fall2024_-_MD._MOZAHEDUL_HOQUE.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101379_Md. Mozahedul Hoque_CSE422_07_Assignment03_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WyjZYh8m-UR6lHiqfbbLi8-HLYeOkm79

PART 1
MORTAL KOMBAT
"""

class MortalKombat:
  def __init__(self, player1):
    self.player1 = player1  # Scorpion is 0 and Sub-Zero is 1
    self.rounds = []
    self.current_round = 1


  def minimax(self,depth, nodeIndex, maximizingPlayer,alpha, beta):
    MAX,MIN = float('-inf'), float('inf')

    # Terminating condition. i.e
    # leaf node is reached
    if depth == 5:
        return self.values(nodeIndex)

    if maximizingPlayer:

        best = MAX

        # Recur for left and right children
        for i in range(2):

            val = self.minimax(depth + 1, nodeIndex * 2 + i, False, alpha, beta)
            best = max(best, val)
            alpha = max(alpha, best)

            # Alpha Beta Pruning
            if beta &lt;= alpha:
                break

        return best

    else:
        best = MIN

        # Recur for left and
        # right children
        for i in range(2):

            val = self.minimax(depth + 1, nodeIndex * 2 + i, True, alpha, beta)
            best = min(best, val)
            beta = min(beta, best)

            # Alpha Beta Pruning
            if beta &lt;= alpha:
                break

        return best
<a name="2"></a><font color="#0000FF"><a href="match123-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

  def values(self, node_index):

    if self.current_round == 1:
      if self.player1 == 0:
        return 1  # Sub-Zero wins round 1 if Scorpion starts
      else:
        return -1  # Scorpion wins round 1 if Sub-Zero starts
    elif self.current_round == 2:
      return -1  # Scorpion wins round 2
    elif self.current_round == 3:
      return -1  # Scorpion wins round 3
  def simulate_round(self):
</font>    # max_player is True if it's Scorpion's turn, False if it's Sub-Zero's turn
    max_player = self.player1 == 0

<a name="1"></a><font color="#00FF00"><a href="match123-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

    winner = self.minimax(0, 0, max_player, float('-inf'), float('inf'))
    if winner == -1:
      self.rounds.append("Scorpion")
    else:
      self.rounds.append("Sub-Zero")
    self.player1 = 1 - self.player1
    self.current_round += 1

  def simulate_game(self):

    while self.current_round &lt;= 3:
      self.simulate_round()


    round_counts = {}
</font>    for winner in self.rounds:
      if winner in round_counts:
        round_counts[winner] += 1
      else:
        round_counts[winner] = 1


<a name="3"></a><font color="#00FFFF"><a href="match123-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

    game_winner = max(round_counts, key=round_counts.get)
    return game_winner, self.rounds


if __name__ == "__main__":

  player1 = int(input("Ke kheltese: "))
  game = MortalKombat(player1)
  game_winner, rounds = game.simulate_game()

  print(f"Game Winner: {game_winner}")
  print(f"Total Rounds Played: {len(rounds)}")
  for i, round_winner in enumerate(rounds, 1):
</font>    print(f"Winner of Round {i}: {round_winner}")

"""PART 2 PACMAN

"""

def alpha_beta_pruning(depth, node_index, max_player, outcomes, alpha, beta):
    # Terminal condition: for when we've reached a certain depth (leaf node)
    if depth == 3:  # Fix depth to match the outcomes tree
        return outcomes[node_index]

    if max_player:
        max_eval = float('-inf')
        for i in range(2):  # Two children: left and right
            eval = alpha_beta_pruning(depth + 1, node_index * 2 + i, False, outcomes, alpha, beta)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for i in range(2):  # Two children: left and right
            eval = alpha_beta_pruning(depth + 1, node_index * 2 + i, True, outcomes, alpha, beta)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break
        return min_eval


def pacman_game(c):
<a name="0"></a><font color="#FF0000"><a href="match123-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

    outcomes = [3, 6, 2, 3, 7, 1, 2, 0]

    minimax_value = alpha_beta_pruning(0, 0, True, outcomes, float('-inf'), float('inf'))


    left_subtree_value = max(outcomes[0], outcomes[1]) - c
    right_subtree_value = max(outcomes[4], outcomes[5]) - c

    # Determine strategy
    if left_subtree_value &gt; right_subtree_value:
        new_minimax_value = left_subtree_value
        direction = "left"
    else:
        new_minimax_value = right_subtree_value
        direction = "right"

    # Check whether dark magic good or bad
    if new_minimax_value &gt; minimax_value:
</font>        print(f"The new minimax value is {new_minimax_value}. Pacman goes {direction} and uses dark magic.")
    else:
        print(f"The minimax value is {minimax_value}. Pacman does not use dark magic.")



c = float(input("Enter the cost of using dark magic: "))
pacman_game(c)</pre>
</body>
</html>
