<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/9/21201680_LAB3_SEC9_Sadman_Rahman_Tasawar_-_SADMAN_RAHMAN_TASAWAR.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/11/22101661_farzina_saima_cse422_11_lab_assignment3_fall2024_-_FARZINA_SAIMA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101661_Farzina_Saima_CSE422_11_Lab_Assignment3_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q0zUCseMDyEG7sPnH7jWwcIEiGaIHM_z
<a name="1"></a><font color="#00FF00"><a href="match41-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_26.gif"/></a>

"""

import random


def alpha_beta_prune(node, depth, alpha, beta, is_maximizing_player, results_map):
    if depth == 0 or node in results_map:
        return results_map.get(node, 0)
    elif is_maximizing_player:
        max_value = float('-inf')
        for child_node in generate_children(node):
            evaluation = alpha_beta_prune(child_node, depth - 1, alpha, beta, False, results_map)
            max_value = max(max_value, evaluation)
            alpha = max(alpha, evaluation)
            if beta &lt;= alpha:
                break
        return max_value
    else:
        min_value = float('inf')
        for child_node in generate_children(node):
            evaluation = alpha_beta_prune(child_node, depth - 1, alpha, beta, True, results_map)
            min_value = min(min_value, evaluation)
            beta = min(beta, evaluation)
            if beta &lt;= alpha:
                break
        return min_value


def generate_children(node):
    return [node * 2 + 1, node * 2 + 2]


class MortalCombat:
    def __init__(self, starting_player):
        self.starting_player = starting_player
        self.max_depth = 5
        self.results_map = self.create_outcomes()
</font>        self.round_results = []

    def create_outcomes(self):
        total_leaves = 2 ** self.max_depth
        if self.starting_player == 0:
            return {i: -1 for i in range(total_leaves)}
        else:
            return {i: 1 for i in range(total_leaves)}

    def simulate_round(self, active_player):
        root_node = 0
        is_maximizing_player = active_player == 1
        winner = alpha_beta_prune(
            root_node, self.max_depth, float('-inf'), float('inf'), is_maximizing_player, self.results_map
        )
<a name="2"></a><font color="#0000FF"><a href="match41-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

        return "Scorpion" if winner == -1 else "Sub-Zero"

    def simulate_war(self):
        total_rounds = 3
        active_player = self.starting_player

        for _ in range(total_rounds):
            winner = self.simulate_round(active_player)
            self.round_results.append(winner)
            active_player = 1 - active_player

        scorpion_wins = self.round_results.count("Scorpion")
        sub_zero_wins = self.round_results.count("Sub-Zero")
</font>
        if scorpion_wins &gt; sub_zero_wins:
          winner = "Scorpion"
        else:
<a name="3"></a><font color="#00FFFF"><a href="match41-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

          winner = "Sub-Zero"

        return winner, total_rounds, self.round_results




user_input = int(input("Enter who starts first (0 for Scorpion, 1 for Sub-Zero): "))

game = MortalCombat(user_input)
final_winner, total_rounds, round_results = game.simulate_war()

print(f"\nGame winner: {final_winner}")
print(f"Total rounds played: {total_rounds}")
</font><a name="0"></a><font color="#FF0000"><a href="match41-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_32.gif"/></a>

for round_number in range(1, len(round_results) + 1):
    print(f"Winner of round {round_number}: {round_results[round_number - 1]}")

class PacmanGame:
    def __init__(self, magic_cost):
        self.magic_cost = magic_cost
        self.outcome_values = [3, 6, 2, 3, 7, 1, 2, 0]

    def minimax(self, depth, node, is_maximizing_player):
        if depth == 2:
            return self.outcome_values[node]

        if is_maximizing_player:
            return max(self.minimax(depth + 1, node * 2, False),
                       self.minimax(depth + 1, node * 2 + 1, False))
        else:
            return min(self.minimax(depth + 1, node * 2, True),
                       self.minimax(depth + 1, node * 2 + 1, True))

    def apply_magic(self):
        no_magic_value = self.minimax(0, 0, True)

        left_with_magic = max(self.outcome_values[0], self.outcome_values[1]) - self.magic_cost
        right_with_magic = max(self.outcome_values[4], self.outcome_values[5]) - self.magic_cost

        if right_with_magic &gt; left_with_magic and right_with_magic &gt; no_magic_value:
            return right_with_magic, "Pacman goes right and uses dark magic"
        elif left_with_magic &gt; no_magic_value:
            return left_with_magic, "Pacman goes left and uses dark magic"
        else:
            return no_magic_value, "Pacman does not use dark magic"

def pacman_game():
    magic_cost = int(input())
</font>    game = PacmanGame(magic_cost)
    result_value, result_action = game.apply_magic()
    print(f"The minimax value is {result_value}. {result_action}")

pacman_game()</pre>
</body>
</html>
