<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/2/21241025_lab03_-_MIFTAHUL_JANNAH.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/17/24241246_niamul_sec17_cse422_assignment03_-_NIAMUL_HASAN_CHOWDHURY.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24241246_Niamul_SEC17_CSE422_Assignment03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eAX74dU5QkOa5rf_YQxH01-lxngCxQz-

```
# Part 1

```
"""

import random

# Parameters
starting_player = int(input("Who is going to take the lead? "))  # 0 for Scorpion, 1 for Sub-Zero
max_depth = random.randint(1,5)  # Depth of the game tree
branching_factor = 2  # Each node has 2 branches

def assign_leaf_utility():
    """Assign utility values to leaf nodes."""
    return random.choice([-1, 1])

def alpha_beta_pruning(depth, current_player, alpha, beta):
    """
    Simulates the game tree using alpha-beta pruning.
    - depth: Current depth in the tree.
    - current_player: The player whose turn it is (0 for Scorpion, 1 for Sub-Zero).
    - alpha: The best score the maximizer (Sub-Zero) can guarantee.
    - beta: The best score the minimizer (Scorpion) can guarantee.
    Returns: The utility value (-1 for Scorpion win, 1 for Sub-Zero win).
    """
    if depth == max_depth:
        # Leaf node: Assign utility value
        return assign_leaf_utility()

    if current_player == 1:  # Sub-Zero (maximize)
        max_eval = float('-inf')
        for _ in range(branching_factor):
            eval = alpha_beta_pruning(depth + 1, 0, alpha, beta)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break  # Beta cutoff
        return max_eval
    else:  # Scorpion (minimize)
        min_eval = float('inf')
        for _ in range(branching_factor):
            eval = alpha_beta_pruning(depth + 1, 1, alpha, beta)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break  # Alpha cutoff
        return min_eval

# Simulate the battle
round_results = []
current_player = starting_player
for round_number in range(1,max_depth+1):
    result = alpha_beta_pruning(0, current_player, float('-inf'), float('inf'))
    winner = "Scorpion" if result == -1 else "Sub-Zero"
    round_results.append(winner)
    current_player = 1 - current_player  # Alternate starting player

# Determine overall winner
scorpion_wins = round_results.count("Scorpion")
subzero_wins = round_results.count("Sub-Zero")
overall_winner = "Scorpion" if scorpion_wins &gt; subzero_wins else "Sub-Zero"

# Print results
print(f"Game Winner: {overall_winner}")
print(f"Total Rounds Played: {max_depth}")
for i, winner in enumerate(round_results, 1):
    print(f"Winner of Round {i}: {winner}")

"""PART 2

"""

leaf_values = [3, 6, 2, 3, 7, 1, 2, 0]

def minimax_with_dark_magic(c, use_dark_magic):
    """
    Computes the minimax value of the game with the option of using dark magic.
    - c: Cost of using dark magic.
    - use_dark_magic: Boolean, whether Pacman uses dark magic.
    Returns the minimax value considering the strategy.
    """
    if use_dark_magic:
        # Pacman controls the ghost's move, always maximizing.
        left_subtree = max(leaf_values[0:4]) - c
        right_subtree = max(leaf_values[4:]) - c
    else:
        # Regular minimax without dark magic.
        left_subtree = min(max(leaf_values[0:2]), max(leaf_values[2:4]))
        right_subtree = min(max(leaf_values[4:6]), max(leaf_values[6:]))

    # Pacman chooses the maximum value between left and right subtrees.
    return max(left_subtree, right_subtree)


<a name="1"></a><font color="#00FF00"><a href="match247-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

def alpha_beta_pruning(depth, is_maximizing_player, alpha, beta, values, start, end):



    if depth == 3:
        return values[start]

    if is_maximizing_player:
        max_eval = float('-inf')
        for i in range(start, end, (end - start) // 2):
            eval = alpha_beta_pruning(depth + 1, False, alpha, beta, values, i, i + (end - start) // 2)
</font><a name="0"></a><font color="#FF0000"><a href="match247-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break  # Beta cutoff
        return max_eval
    else:
        min_eval = float('inf')
        for i in range(start, end, (end - start) // 2):
            eval = alpha_beta_pruning(depth + 1, True, alpha, beta, values, i, i + (end - start) // 2)
</font><a name="2"></a><font color="#0000FF"><a href="match247-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break  # Alpha cutoff
        return min_eval


# Define the cost of using dark magic
 # Sample inputs

# Results for the given costs

cost = int(input())
</font>without_dark_magic = alpha_beta_pruning(0, True, float('-inf'), float('inf'), leaf_values, 0, len(leaf_values))
with_dark_magic = minimax_with_dark_magic(cost, True)
optimal_strategy = "Pacman goes to right and use dark magic" if with_dark_magic &gt; without_dark_magic else "Pacman does not use dark magic"
final_value = max(with_dark_magic, without_dark_magic)

print(f"The new minimax value is {final_value}. {optimal_strategy}")</pre>
</body>
</html>
