<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/22101094_sec08_lab3_(1)_-_SABAHA_SADIK.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/22101094_sec08_lab3_(1)_-_SABAHA_SADIK.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101094_sec08_lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s5Z_mSKlobggtf-0a__65V_DZ--WQ3rX
"""

#Task 1
import secrets

class MortalKombatGame:
    def __init__(self, fighter_1):

        self.fighter_1 = fighter_1
        self.fighter_2 = 1 - fighter_1
        self.total_rounds = 3
        self.round_winners = []
        print(f"First Fighter: {'Scorpion' if self.fighter_1 == 0 else 'Sub-Zero'}")

    def play_game(self):

        for round_num in range(1, self.total_rounds + 1):
            winner = self.play_round(round_num)
            self.round_winners.append(winner)


        self.display_results()

    def play_round(self, round_num):

        starting_fighter = self.fighter_1 if round_num % 2 != 0 else self.fighter_2


        utility = self.alpha_beta_pruning(starting_fighter, 0, float('-inf'), float('inf'), True)


        return "Scorpion" if utility == -1 else "Sub-Zero"

<a name="1"></a><font color="#00FF00"><a href="match71-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_17.gif"/></a>

    def alpha_beta_pruning(self, fighter, depth, alpha, beta, is_maximizing):

        if depth == 5:
            return secrets.choice([-1, 1])

        if is_maximizing:
            max_eval = float('-inf')
            for _ in range(2):
                evaluation = self.alpha_beta_pruning(1 - fighter, depth + 1, alpha, beta, False)
                max_eval = max(max_eval, evaluation)
                alpha = max(alpha, evaluation)
                if beta &lt;= alpha:
                    break
            return max_eval
        else:
            min_eval = float('inf')
            for _ in range(2):
                evaluation = self.alpha_beta_pruning(1 - fighter, depth + 1, alpha, beta, True)
                min_eval = min(min_eval, evaluation)
                beta = min(beta, evaluation)
</font>                if beta &lt;= alpha:
                    break
            return min_eval

    def display_results(self):

        scorpion_wins = self.round_winners.count("Scorpion")
        subzero_wins = self.round_winners.count("Sub-Zero")


        game_winner = "Scorpion" if scorpion_wins &gt; subzero_wins else "Sub-Zero"


        print(f"Game Winner: {game_winner}")
        print(f"Total Rounds Played: {self.total_rounds}")
        for i, winner in enumerate(self.round_winners, 1):
            print(f"Winner of Round {i}: {winner}")


if __name__ == "__main__":
    try:
        first_fighter = int(input("Enter 0 for Scorpion or 1 for Sub-Zero: "))
        if first_fighter not in [0, 1]:
            raise ValueError("Invalid input. Please enter 0 or 1.")
        game = MortalKombatGame(first_fighter)
        game.play_game()
    except ValueError as e:
        print(f"Error: {e}")

#Task 2
<a name="0"></a><font color="#FF0000"><a href="match71-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_37.gif"/></a>

def minimax(depth, is_maximizing, potential_scores, alpha, beta):

    if depth == 2:
        return potential_scores

    if is_maximizing:
        max_eval = float('-inf')
        for score in potential_scores:
            value = minimax(depth + 1, False, score, alpha, beta)
            max_eval = max(max_eval, value)
            alpha = max(alpha, value)
            if beta &lt;= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for score in potential_scores:
            value = minimax(depth + 1, True, score, alpha, beta)
            min_eval = min(min_eval, value)
            beta = min(beta, value)
            if beta &lt;= alpha:
                break
        return min_eval


def pacman_decision_strategy(cost):

    def adjust_scores_with_magic(scores, cost):
        left = max(scores[0]) - cost
        right = max(scores[2]) - cost
        return left, right

    def evaluate_move(current_value, adjusted_scores):
        if adjusted_scores[0] &gt; adjusted_scores[1]:
            best_value = adjusted_scores[0]
            move = "left"
        else:
            best_value = adjusted_scores[1]
            move = "right"

        if best_value &gt; current_value:
            print(f"New minimax value: {best_value}. Pacman moves {move} using dark magic.")
        else:
            print(f"Minimax value: {current_value}. Pacman does not use dark magic.")


    potential_scores = [[3, 6], [2, 3], [7, 1], [2, 0]]
    root_minimax_value = minimax(0, True, potential_scores, float('-inf'), float('inf'))


    adjusted_scores = adjust_scores_with_magic(potential_scores, cost)


    evaluate_move(root_minimax_value, adjusted_scores)


if __name__ == "__main__":
    cost_input = int(input("Enter the cost of using dark magic: "))
    pacman_decision_strategy(cost_input)</font></pre>
</body>
</html>
