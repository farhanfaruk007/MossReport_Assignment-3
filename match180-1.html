<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/22101365_Majedul_Islam_08_-_MAJEDUL_ISLAM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/22101934_subha_422(8)_assign3_-_SUBHA_CHOWDHURY.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101934_subha_422(8)_assign3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i5F8LX926YeMmamjv8myzOh1fsuKcKvS
"""

#task01

import random

class TreeNode:
  def __init__(self,value=None):
    self.value =value
    self.left=None
    self.right=None

def create_tree(depth,cur_depth=0):        #binary tree creation
  if cur_depth==depth:
    return None
  node=TreeNode(cur_depth)
  node.left=create_tree(depth,cur_depth+1)
  node.right=create_tree(depth,cur_depth+ 1)
  return node

def is_leaf(node):               #chevk if the node is the leaf node or not
  if node.left is None and node.right is None:
    return True
  else:
    return False

def random_values_leaf(node):     #assign -1 or 1 value to the leaf nodes
  if node is None:
    return
  if is_leaf(node):
    node.value=random.choice([-1,1])
  else:
    random_values_leaf(node.left)
    random_values_leaf(node.right)

def update_leaf(node):             #after every round the values of the nodes get updated randomly
  if node.left is None and node.right is None:
    node.value=random.choice([-1,1])
  else:
    if node.left is not None:
      update_leaf(node.left)
    if node.right is not None:
      update_leaf(node.right)

def terminal_test(state):
  return is_leaf(state)

def utility(state):
  return state.value

def successors(state):
  if state.left is None and state.right is None:
    return []
<a name="1"></a><font color="#00FF00"><a href="match180-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

  return [state.left,state.right]

def max_value(state,alpha,beta):
  if terminal_test(state):
    return utility(state)
  v=float('-inf')
  for s in successors(state):
    v=max(v, min_value(s,alpha,beta))
    if v&gt;=beta:
      return v
    alpha=max(alpha,v)
  return v

def min_value(state,alpha,beta):
</font>  if terminal_test(state):
    return utility(state)
  v=float('inf')
  for s in successors(state):
    v=min(v, max_value(s, alpha, beta))
    if v&lt;= alpha:
      return v
    beta=min(beta, v)
  return v

def alpha_beta_algo(state, player):
  a=float('-inf')
  b=float('inf')
  if player:
    return max_value(state,a,b)
  else:
    return min_value(state,a,b)

depth=5          #depth of tree is 5
root=create_tree(depth)
random_values_leaf(root)

wins={'Scorpion':0,'Sub-Zero':0}  #keeing the winner track

start = int(input())       #0-&gt;scor, 1-&gt;sub

print("Total Rounds Played: 3")

for round in range(3):    # game will be played in 3 rounds
  if (start+round)% 2==0:
    result=alpha_beta_algo(root,True)  # 1st round= scor
  else:
    result=alpha_beta_algo(root,False)  #1st round= sub


  if result==1:
    winner='Scorpion'
  else:
    winner='Sub-Zero'
  wins[winner]+= 1
  print(f"Winner of Round {round + 1}: {winner}")
  update_leaf(root)

  # if result==1:
  #   winner='Scorpion'
  # else:
  #   winner='Sub-zero'
  # wins[winner]+= 1
  # print(f"Winner of the Round {round+1}: {winner}")
  #update_leaf(root)

act_winner = max(wins, key=wins.get) #actual winner
print(f"Game Winner: {act_winner}")
#print("Total Rounds Played: 3")

#task 02
def terminal_test(state):
  #return state
  return isinstance(state,int)

def utility(state):
  return state

def successors(state):
  return state

def max_value(state,alpha,beta):
<a name="0"></a><font color="#FF0000"><a href="match180-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

  if terminal_test(state):
    return utility(state)
  v=float('-inf')
  for s in successors(state):
    v=max(v, min_value(s,alpha,beta))
    if v&gt;=beta:
      return v
    alpha=max(alpha,v)
  return v

def min_value(state,alpha,beta):
  if terminal_test(state):
    return utility(state)
  v=float('inf')
  for s in successors(state):
    v=min(v, max_value(s,alpha,beta))
    if v&lt;=alpha:
      return v
    beta=min(beta,v)
  return v

def alpha_beta_algo(state):         #this algo will return the actual minmax value of the input
  a=float('-inf')
</font>  b=float('inf')
  return max_value(state,a,b)

tree=[[[3, 6],[2, 3]],[[7, 1],[2, 0]]]   #root-&gt;n1,n2 | n1-&gt;n3,n4 | n3-&gt;3,6 | n4-&gt;2,3
                                         #n2-&gt;n5,n6 | n5-&gt;7,1 | n6-&gt;2,0

minmax_value=alpha_beta_algo(tree)
#print("minmax value:", minmax_value)

def new_max_value(node,alpha,beta):
    if terminal_test(node):
        return utility(node)
    v=float('-inf')
    for s in successors(node):
        v=max(v,new_max_value(s, alpha, beta))
        if v&gt;= beta:
            return v
        alpha=max(alpha, v)
    return v

def modified_alpha_beta(node):              #this algo will return the minmax value without the oponent, where all turn will be maximized.
  a=float('-inf')
  b=float('inf')
  return new_max_value(node,a,b)




#print("new minimax value:", modified_minmax_value)

cost=int(input())

def pacman(cost):
  minmax_value=alpha_beta_algo(tree)
  modified_minmax_value=modified_alpha_beta(tree)
  modified_minmax_value -=cost

  if modified_minmax_value&lt; minmax_value:
    print("Pacman does not need to use dark magic.minmax value:",minmax_value)
  else:
    print("Pacman goes right and uses dark magic.minimax value:",modified_minmax_value)

result=pacman(cost)</pre>
</body>
</html>
