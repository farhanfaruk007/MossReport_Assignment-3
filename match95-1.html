<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/21201752_nabiha_binte_yousuf_cse422_07_lab_assignment03_fall2024_-_NABIHA_BINTE_YOUSUF.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/14/24341261_cse422_14_labassignment3_-_TANJINA_FARIA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24341261_CSE422_14_LabAssignment3

Automatically generated by Colab.

Original file is located at
<a name="1"></a><font color="#00FF00"><a href="match95-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

    https://colab.research.google.com/drive/1BwRavuGt4jXJPyYHiYIgISAw76t74L4Y
"""

# Mortal Kombat Game
class CombatGame:
    def __init__(self, first_player):
        self.current_player = first_player
        self.max_depth = 5
        self.children_count = 2
        self.rounds_played = 0
        self.round_results = []



    def simulate_game(self):
</font>        total_rounds=3
        while self.rounds_played&lt;total_rounds:

            if self.rounds_played==0:
                self.node_values=[1 for _ in range(2 ** self.max_depth)]
            else:
                self.node_values=[-1 for _ in range(2 ** self.max_depth)]


            result=self.evaluate_moves(0, 0, self.current_player==1, float('-inf'), float('inf'))
            winner="Scorpion" if result== -1 else "Sub-Zero"
            self.round_results.append(winner)


            self.current_player= 1 - self.current_player
            self.rounds_played+= 1


        final_winner= max(set(self.round_results), key=self.round_results.count)
        return final_winner, self.rounds_played, self.round_results

    def evaluate_moves(self, level, position, is_max_turn, alpha, beta):

        if level== self.max_depth:
<a name="2"></a><font color="#0000FF"><a href="match95-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

            return self.node_values[position]

        if is_max_turn:
            best_score=float('-inf')
            for child in range(self.children_count):
                score=self.evaluate_moves(level + 1, position * 2 + child, False, alpha, beta)
</font>                best_score=max(best_score, score)
                alpha=max(alpha, score)
                if beta&lt;= alpha:
                    break
            return best_score
<a name="3"></a><font color="#00FFFF"><a href="match95-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

        else:
            worst_score= float('inf')
            for child in range(self.children_count):
                score= self.evaluate_moves(level + 1, position * 2 + child, True, alpha, beta)
</font>                worst_score = min(worst_score, score)
                beta= min(beta, score)
                if beta&lt;= alpha:
                    break
            return worst_score

player= int(input("Enter starting player (0 or 1): "))
<a name="0"></a><font color="#FF0000"><a href="match95-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_17.gif"/></a>

mortal_kombat= CombatGame(player)
champion, rounds, results= mortal_kombat.simulate_game()

print(f"Champion: {champion}")
print(f"Rounds Played: {rounds}")
for i, result in enumerate(results):
    print(f"Round {i + 1} Winner: {result}")



class GhostHunter:
    def __init__(self, magic_cost):
        self.terminal_scores=[3, 6, 2, 3, 7, 1, 2, 0]
        self.magic_penalty= magic_cost
        self.child_nodes= 2

    def minimax(self, depth, index, is_maximizer, alpha, beta):

        if depth== 3:
            return self.terminal_scores[index]

        if is_maximizer:
            max_score= float('-inf')
            for child in range(self.child_nodes):
                score= self.minimax(depth + 1, index * 2 + child, False, alpha, beta)
</font>                max_score= max(max_score, score)
                alpha= max(alpha, score)
                if beta&lt;= alpha:
                    break
            return max_score
<a name="4"></a><font color="#FF00FF"><a href="match95-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

        else:
            min_score= float('inf')
            for child in range(self.child_nodes):
                score= self.minimax(depth + 1, index * 2 + child, True, alpha, beta)
</font>                min_score = min(min_score, score)
                beta= min(beta, score)
                if beta&lt;= alpha:
                    break
<a name="5"></a><font color="#FF0000"><a href="match95-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

            return min_score


    def determine_strategy(self):
        score_no_magic= self.evaluate_no_magic()
        score_with_magic= self.evaluate_with_magic()

        if score_with_magic &gt; score_no_magic:
            print(f"Optimized score is {score_with_magic}. Pacman uses magic and chooses the right path.")
        else:
            print(f"Standard score is {score_no_magic}. Pacman avoids magic.")
</font>    def evaluate_with_magic(self):
        left_max= max(self.terminal_scores[:4])
        right_max= max(self.terminal_scores[4:])
        return max(left_max - self.magic_penalty, right_max - self.magic_penalty)

    def evaluate_no_magic(self):
        return self.minimax(0, 0, True, float('-inf'), float('inf'))


magic_cost = int(input("Enter the magic cost: "))
pacman_game = GhostHunter(magic_cost)
pacman_game.determine_strategy()</pre>
</body>
</html>
