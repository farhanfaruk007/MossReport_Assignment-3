<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/3/23241066_nafim_rahman_cse422_03_lab_assignment03_fall2024_-_NAFIM_RAHMAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/3/23241066_nafim_rahman_cse422_03_lab_assignment03_fall2024_-_NAFIM_RAHMAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""23241066_Nafim Rahman_CSE422_03_Lab_Assignment03_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qhOY33Si_dur23zEVKs2Zootitect5xk

Part 1
"""

branching_factor=2
max_tree_depth=5

Scorpion=0

import random

def Mortal_Kombat(player1): #function to simulate the game
  branching_factor=2
  tree_depth=5
  players={0:"Scorpion", 1:"Sub-Zero"} #storing players as key:value player in a dict for easier identification from input

  def tree_maker(current_depth): #recurse function to build game tree. This function uses the depth of the tree to build a tree by using the base case as 0.
    if current_depth==0:  #although this is the bottom most level, this is defined as 0th level here so that the leaf node is treated as the base case
      return random.choice([1,-1]) #randomly assign win or loss
    return [tree_maker(current_depth-1) for i in range(branching_factor)]

  def game_play(current_player): #function that uses the input of current player to ran a simulation of game play
    game_tree=tree_maker(tree_depth) #makes a tree of random depth between 2 and 5, 2 to 5 rounds
    root_value=alpha_beta_pruning(game_tree,tree_depth,float('-inf'),float('inf'),current_player,players)
    if root_value==1:
      winner=1 #sub-zero
    else:
      winner=0 #scorpion
    return winner

  current_player=player1 #initializing current player with the first player
  winner_list=[] #list to store winners of each round (0 or 1)
  rounds=random.randint(2,5)
  for round in range(rounds): #random number of rounds being played
    r_winner=game_play(current_player) #winner of current round
    if r_winner==0: #updating winner list
      winner_list.append("Scorpion")
    else:
      winner_list.append("Sub-Zero")

    current_player=1-current_player #alternating players

  #calculation of game winner
  winner= None
  Scorpion=winner_list.count(0)
  Sub_Zero=winner_list.count(1)
  if Scorpion&gt;Sub_Zero:
    winner="Scorpion"
  else:
    winner="Sub-Zero"

  print(f""" Game Winner: {winner} \nTotal Rounds Played: {rounds}""")
  for i in range(rounds):
    print(f"Winner of Round {i+1}: {winner_list[i]}")

def alpha_beta_pruning(node,depth,alpha,beta,maximizing_player,players):
  if depth==0: #checking if leaf node
    return node

  if maximizing_player: #maximizing level
    best_score = float('-inf') #intiliazing max value with negative infinity
    for child in node:
      score = alpha_beta_pruning(child, depth - 1, alpha, beta, False, players)
      best_score = max(best_score, score) #comparing and updating max value
      alpha = max(alpha, score)
      if alpha&gt;=beta: #pruning condition
        break
    return best_score
  else: #minimizing level
    best_score = float('inf')  #intiliazing min value with infinity
    for child in node:
      score = alpha_beta_pruning(child, depth - 1, alpha, beta, True, players)
      best_score = min(best_score, score)
      beta = min(beta, score)
      if alpha&gt;=beta:
        break
    return best_score

player1 = int(input("Enter the starting player (0 for Scorpion, 1 for Sub-Zero): "))
Mortal_Kombat(player1)

"""Part 2"""

import random

<a name="0"></a><font color="#FF0000"><a href="match192-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

def pacman_game(int_c):
    leaf_values = [3, 6, 2, 3, 7, 1, 2, 0]

    def build_game_tree():
        return [
            [leaf_values[0], leaf_values[1]],  # Pacman makes a move
            [leaf_values[2], leaf_values[3]],  # Ghost blocks
            [leaf_values[4], leaf_values[5]],  # Pacman makes a move
            [leaf_values[6], leaf_values[7]],  # Ghost blocks
</font>        ]

    # Alpha-Beta Pruning function
    def alpha_beta_pruning(node,depth,alpha,beta,maximizing_player):
      if depth==0: #checking if leaf node
        return node

      if maximizing_player: #maximizing level
        best_score = float('-inf') #intiliazing max value with negative infinity
<a name="1"></a><font color="#00FF00"><a href="match192-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

        for child in node:
          if isinstance(child, int): #checking if leaf node, because leaf node is score here
            score = child
          else:
            score = alpha_beta_pruning(child, depth - 1, alpha, beta, False)
          best_score = max(best_score, score) #comparing and updating max value
          alpha = max(alpha, score)
          if alpha&gt;=beta: #pruning condition
</font>            break
        return best_score
      else: #minimizing level
        best_score = float('inf')  #intiliazing min value with infinity
<a name="2"></a><font color="#0000FF"><a href="match192-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

        for child in node:
          if isinstance(child, int):
            score = child
          else:
            score = alpha_beta_pruning(child, depth - 1, alpha, beta, True)
          best_score = min(best_score, score)
          beta = min(beta, score)
          if alpha&gt;=beta:
</font>            break
        return best_score

    game_tree = build_game_tree()

    minimax_value_no_magic = alpha_beta_pruning(game_tree, 3, float('-inf'), float('inf'), True)

    game_tree_with_magic = build_game_tree()
    for i in range(len(game_tree_with_magic)):
        for j in range(len(game_tree_with_magic[i])):
            game_tree_with_magic[i][j] -= c  # Deduct the cost of dark magic

    minimax_value_with_magic = alpha_beta_pruning(game_tree_with_magic, 3, float('-inf'), float('inf'), True)

    print(f"The minimax value without dark magic: {minimax_value_no_magic}")
    print(f"The minimax value with dark magic: {minimax_value_with_magic}")

    # Determine if using dark magic is advantageous
    if minimax_value_with_magic &gt; minimax_value_no_magic:
        print(f"Using dark magic is advantageous.")
    else:
        print(f"Using dark magic is not advantageous.")

c = int(input("Enter the cost of dark magic: "))
pacman_game(c)

"""Part 3"""

#In our cases, the first player is mazimizer node, as it tries to maximize its score and minimize its opponents

#Alpha-beta pruning would not be able to effectively handle stochastic environments as it needs a set depth
#and we know possible outcomes.So it will not work for environments where the outcomes are uncertain.</pre>
</body>
</html>
