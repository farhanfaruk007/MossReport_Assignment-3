<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/24141238_Muhammed_Irtiza_Mahmood_cse422_08_lab_assignment03_-_MUHAMMED_IRTIZA_MAHMOOD.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/9/22101727_assignment03_NabihaBinteNasim_-_NABIHA_BINTE_NASIM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""Untitled43.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1avSIzcY-h62Zg_2-CkcnlpB4kWt1t_AJ
<a name="1"></a><font color="#00FF00"><a href="match30-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_22.gif"/></a>

"""

import random
MAX_DEPTH = 5
BRANCH_FACTOR = 2

def minimax_with_pruning(position, depth, alpha, beta, maximizing_player):
    if depth == 0 or is_leaf_node(position):
        return evaluate_position(position)

    if maximizing_player:
        value = -float('inf')
        for move in range(BRANCH_FACTOR):
            next_position = generate_child(position, move)
            value = max(value, minimax_with_pruning(next_position, depth - 1, alpha, beta, False))
            alpha = max(alpha, value)
            if beta &lt;= alpha:
                break
        return value
    else:
        value = float('inf')
        for move in range(BRANCH_FACTOR):
            next_position = generate_child(position, move)
            value = min(value, minimax_with_pruning(next_position, depth - 1, alpha, beta, True))
            beta = min(beta, value)
            if beta &lt;= alpha:
                break
        return value

def is_leaf_node(position):
    return calculate_depth(position) == MAX_DEPTH

def evaluate_position(position):
</font>    return -1 if position % 2 == 0 else 1

<a name="2"></a><font color="#0000FF"><a href="match30-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

def generate_child(state, action):
    return state * BRANCH_FACTOR + action + 1

def calculate_depth(state):
    return len(bin(state)) - 2

def run_game_simulation(first_player):
    total_rounds = 0
    scorpion_wins = 0
    sub_zero_wins = 0
    current_player = first_player
    match_results = []

    while total_rounds &lt; 3:
</font>        total_rounds += 1
        winner = "Scorpion" if random.choice([0, 1]) == 0 else "Sub-Zero"
        if winner == "Scorpion":
            scorpion_wins += 1
        else:
            sub_zero_wins += 1
<a name="0"></a><font color="#FF0000"><a href="match30-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_53.gif"/></a>

        match_results.append(f"Winner of Round {total_rounds}: {winner}")
        current_player = 1 - current_player

    if scorpion_wins &gt; sub_zero_wins:
        game_winner = "Scorpion"
    elif sub_zero_wins &gt; scorpion_wins:
        game_winner = "Sub-Zero"
    else:
        game_winner = "Draw"

    return game_winner, total_rounds, match_results

def main():
    starting_player = None
    while starting_player not in ["0", "1"]:
        starting_player = input("Enter 0 for Scorpio to start or 1 for Sub-Zero: ")
    starting_player = int(starting_player)

    winner, total_rounds, results = run_game_simulation(starting_player)

    print(f"Game Winner: {winner}")
    print(f"Total Rounds Played: {total_rounds}")
    for result in results:
        print(result)

if __name__ == "__main__":
    main()

def pacman_game():
    c = int(input("Enter the cost of using dark magic (c): "))
    score = [3, 6, 2, 3, 7, 1, 2, 0]

    def evaluate_tree(node, depth, alpha, beta, maximize):
        if depth == 0:
            return score[node]

        if maximize:
            best_value = float('-inf')
            start_index = 2 * node
            end_index = start_index + 2
            for child in range(start_index, end_index):
                value = evaluate_tree(child, depth - 1, alpha, beta, False)
                best_value = max(best_value, value)
                alpha = max(alpha, value)
                if beta &lt;= alpha:
                    break
            return best_value

        else:
            best_value = float('inf')
            start_index = 2 * node
            end_index = start_index + 2
            for child in range(start_index, end_index):
                value = evaluate_tree(child, depth - 1, alpha, beta, True)
                best_value = min(best_value, value)
                beta = min(beta, value)
                if beta &lt;= alpha:
                    break
            return best_value

    root_value_no_magic = evaluate_tree(0, 3, float('-inf'), float('inf'), True)

    left_branch_with_magic = [val - c for val in [score[0], score[1]]]
    right_branch_with_magic = [val - c for val in [score[4], score[5]]]

    max_left = max(left_branch_with_magic)
    max_right = max(right_branch_with_magic)
    max_with_magic = max(max_left, max_right)

    if max_with_magic &gt; root_value_no_magic:
        if max_left &gt; max_right:
            print(f"The new minimax value is {max_left}. Pacman goes left and uses dark magic")
        else:
            print(f"The new minimax value is {max_right}. Pacman goes right and uses dark magic")
    else:
</font>        print(f"The minimax value is {root_value_no_magic}. Pacman does not use dark magic")

pacman_game()

</pre>
</body>
</html>
