<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/6/21101096_a_b_m_danial_cse422_06_assignment03_fall2024_-_A.B.M_DANIAL.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/6/21101096_a_b_m_danial_cse422_06_assignment03_fall2024_-_A.B.M_DANIAL.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21101096_a_b_m_danial_cse422_06_assignment03_fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14U18nF7WfzZ-Z-HvTCOQIlaKQmwoR1pp
"""

#task 1

import random
class Tree:
    def __init__(self):
        self.value = None
        self.left_node = None
        self.right_node = None

<a name="1"></a><font color="#00FF00"><a href="match67-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

def tree_creation(depth):
    total_node = 2**(depth + 1) - 1
    node = []
    for i in range(total_node):
        node.append(Tree())
    for j in range(2**depth - 1):
        node[j].left_node = node[2*j + 1]
        node[j].right_node = node[2*j + 2]
</font>    for k in range(2**depth - 1,len(node)): #leaf_node_start_idx = 2**depth - 1
        node[k].value = random.choice([-1, 1])
    return node[0]

def alphabeta_pruning(node, depth, maximizing, alpha, beta, max_depth):
    if depth == max_depth or (node.left_node == None and node.right_node == None):
        return node.value
    if maximizing == True:
<a name="0"></a><font color="#FF0000"><a href="match67-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_12.gif"/></a>

        C = -float("inf")
        if node.left_node:
            C = max(C, alphabeta_pruning(node.left_node, depth + 1, False, alpha, beta, max_depth))
        if node.right_node:
            C = max(C, alphabeta_pruning(node.right_node, depth + 1, False, alpha, beta, max_depth))
        alpha = max(alpha, C)
        if alpha &gt;= beta:
            return C
        return C
    else:
        C = float("inf")
        if node.left_node:
            C = min(C, alphabeta_pruning(node.left_node, depth + 1, True, alpha, beta, max_depth))
        if node.right_node:
            C = min(C, alphabeta_pruning(node.right_node, depth + 1, True, alpha, beta, max_depth))
        beta = min(beta,C)
        if alpha &gt;= beta:
            return C
        return C

def battle(start_player, depth, round):
</font>    root = tree_creation(depth)
    scorpion, subzero = 0, 0
    player = start_player
    scoreboard = []
    for i in range(round):
        if player == 0:
            flag = True
        else:
            flag = False
        winner = alphabeta_pruning(root, 0, flag, -float('inf'), float('inf'), depth)
        if winner == -1:
            scoreboard.append("Scorpion")
        else:
            scoreboard.append("Sub-Zero")
        player = 1 - player
    for j in scoreboard:
        if j == "Scorpion":
            scorpion += 1
        else:
            subzero += 1
    check = max(scorpion, subzero)
    if check == scorpion:
        winner = "Scorpion"
    else:
        winner = "Sub-Zero"
    return winner, scoreboard

round = 3
depth = 4
start_player = int(input())
winner, scoreboard = battle(start_player, depth, round)
print(f"Game Winner: {winner}")
print(f"Total Rounds Played: {round}")
for i in range(1,round + 1):
    print(f"Winner of Round {i}: {scoreboard[i - 1]}")

#task-2

class Tree:
    def __init__(self):
        self.value = None
        self.left_node = None
        self.right_node = None

def tree_creation(depth, leaf_value):
    total_node = 2**(depth + 1) - 1
    node = []
    for i in range(total_node):
        node.append(Tree())
    for j in range(2**depth - 1):
        node[j].left_node = node[2*j + 1]
        node[j].right_node = node[2*j + 2]
<a name="3"></a><font color="#00FFFF"><a href="match67-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

    leaf_node_start_idx = 2**depth - 1
    for k in range(len(leaf_value)):
        node[leaf_node_start_idx + k].value = leaf_value[k]
    return node[0]

def normal_minimax_pruning(node, depth, maximizing, alpha, beta, max_depth):
</font>    if depth == max_depth or (node.left_node == None and node.right_node == None):
        return node.value

    if maximizing == True:
<a name="2"></a><font color="#0000FF"><a href="match67-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

        C = -float("inf")
        if node.left_node:
            C = max(C, normal_minimax_pruning(node.left_node, depth+1, False, alpha, beta, max_depth))
        if node.right_node:
            C = max(C, normal_minimax_pruning(node.right_node, depth+1, False, alpha, beta, max_depth))
        alpha = max(alpha, C)
        if alpha &gt;= beta:
            return C
        return C
</font>    else:
        C=float("inf")
        if node.left_node:
            C = min(C, normal_minimax_pruning(node.left_node, depth+1, True, alpha, beta, max_depth))
        if node.right_node:
            C = min(C, normal_minimax_pruning(node.right_node, depth+1, True, alpha, beta, max_depth))
        beta=min(beta, C)
        if alpha &gt;= beta:
            return C
        return C

def dark_minimax_pruning(node, depth, maximizing, alpha, beta, max_depth):
    if depth == max_depth or (node.left_node == None and node.right_node == None):
        return node.value
    if maximizing == True:
        C = -float("inf")
        if node.left_node:
            C = max(C, dark_minimax_pruning(node.left_node, depth+1, True, alpha, beta, max_depth))
        if node.right_node:
            C = max(C,dark_minimax_pruning(node.right_node, depth+1, True, alpha, beta, max_depth))
        alpha = max(alpha,C)
        if alpha &gt;= beta:
            return C
        return C
<a name="4"></a><font color="#FF00FF"><a href="match67-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>


def battle(c, depth, leaf_value):
    root = tree_creation(depth, leaf_value)
    normal_max = normal_minimax_pruning(root, 0, True, -float("inf"), float("inf"), depth)
    dark_max = dark_minimax_pruning(root, 0, True, -float("inf"), float("inf"), depth)
    return normal_max, dark_max
</font>
def path(leaf_value):
    left_path = max(leaf_value[0:4])
    right_path = max(leaf_value[4:])
    return left_path, right_path
c = int(input())

depth = 3
leaf_value = [3,6,2,3,7,1,2,0]
left_path, right_path = path(leaf_value)
if left_path &gt; right_path:
    path = "left"
elif left_path &lt; right_path:
    path = "right"
else:
    path = "anypath"
normal_max, dark_max = battle(c, depth, leaf_value)
no_dark, dark = normal_max, dark_max - c

if dark &gt; no_dark:
    print(f"The new minimax value is {dark}. Pacman goes {path} and uses dark magic.")
elif dark == no_dark:
    print(f"The minimax value is always {no_dark}. Pacman may or may not use dark magic.")
else:
    print(f"The minimax value is {no_dark}. Pacman does not use dark magic.")</pre>
</body>
</html>
