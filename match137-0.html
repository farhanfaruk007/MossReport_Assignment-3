<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/11/22101650_md_ashiqur_rahman_abir_cse422_11_lab_assignment3_fall2024_-_MD._ASHIQUR_RAHMAN_ABIR.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/11/22101650_md_ashiqur_rahman_abir_cse422_11_lab_assignment3_fall2024_-_MD._ASHIQUR_RAHMAN_ABIR.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101650_Md_Ashiqur_Rahman_Abir_cse422_11_lab_assignment3_fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xRXyqJ6lBU9fA8-dH8ooFcD5nPWtH8AJ
"""

#Part 1

import random

# Get input from the user with validation (only 0 or 1 allowed)
while True:
    player_start = int(input("Enter the starting player (0 for Scorpion, 1 for Sub-Zero): ").strip())
    if player_start in [0, 1]:
        break
    print("Invalid input! Please enter 0 for Scorpion or 1 for Sub-Zero.")

class BattleTree:
<a name="0"></a><font color="#FF0000"><a href="match137-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_31.gif"/></a>

    def __init__(self, value=None, children=None, branching_factor=2, max_depth=5):
        self.value = value
        self.children = children if children is not None else []
        self.branching_factor = branching_factor
        self.max_depth = max_depth

    def build_tree(self, depth):
        # Base case: Leaf nodes with utility values (-1 for Scorpion win, 1 for Sub-Zero win)
        if depth == 0:
            return BattleTree(random.choice([-1, 1]))
        else:
            node = BattleTree()
            node.children = [self.build_tree(depth - 1) for _ in range(self.branching_factor)]
            return node

    def alpha_beta_search(self, node, depth, alpha, beta, is_maximizing_player):
        if node.value is not None or depth == 0:
            return node.value

        if is_maximizing_player:
            best_value = -float('inf')
            for child in node.children:
                best_value = max(best_value, self.alpha_beta_search(child, depth - 1, alpha, beta, False))
                alpha = max(alpha, best_value)
                if beta &lt;= alpha:
                    break
            return alpha
        else:
            best_value = float('inf')
            for child in node.children:
                best_value = min(best_value, self.alpha_beta_search(child, depth - 1, alpha, beta, True))
                beta = min(beta, best_value)
                if beta &lt;= alpha:
</font>                    break
            return beta

    def run_game(self, starting_player):
        root = self.build_tree(self.max_depth)

        rounds_played = 0
        round_winners = []

        scorpion_count = 0
        sub_zero_count = 0

        while rounds_played &lt; 3:  # Max rounds are 3 as the default match number in Mortal Kombat is 3.
            alpha = -float('inf')  # Reset alpha for each round
            beta = float('inf')    # Reset beta for each round

            # Simulate the round with randomness for outcome
            round_winner = random.choice(["Scorpion", "Sub-Zero"])  # Random winner for each round

            if round_winner == "Scorpion":
                scorpion_count += 1
            else:
                sub_zero_count += 1

            round_winners.append(round_winner)
            rounds_played += 1

            if scorpion_count == 2 or sub_zero_count == 2:  # If any player wins 2 rounds, break
                break

            # Switch players for next round
            starting_player = 1 - starting_player

        # Determine the overall winner based on who won 2 rounds
        game_winner = "Scorpion" if scorpion_count &gt; sub_zero_count else "Sub-Zero"

        return game_winner, round_winners, rounds_played


battle = BattleTree()
game_winner, round_winners, total_rounds = battle.run_game(player_start)

print("\nGame Results:")
print(f"Game Winner: {game_winner}")
print(f"Total Rounds Played: {total_rounds}")
for i in range(total_rounds):
    print(f"Winner of Round {i + 1}: {round_winners[i]}")

#Part 2
def calculate_minimax(level, current_node, maximizing_player, scores, alpha, beta):
    if level == 3:
        return scores[current_node]

    if maximizing_player:
        best_score = float('-inf')
        for next_move in range(2):
            child_node = current_node * 2 + next_move
            score = calculate_minimax(level + 1, child_node, False, scores, alpha, beta)
            best_score = max(best_score, score)
            alpha = max(alpha, score)
            if beta &lt;= alpha:
                break
        return best_score
    else:
        best_score = float('inf')
        for next_move in range(2):
            child_node = current_node * 2 + next_move
            score = calculate_minimax(level + 1, child_node, True, scores, alpha, beta)
            best_score = min(best_score, score)
            beta = min(beta, score)
            if beta &lt;= alpha:
                break
        return best_score


def pacman_decision(dark_magic_cost):
    score_values = [3, 6, 2, 3, 7, 1, 2, 0]

    basic_minimax = calculate_minimax(0, 0, True, score_values, float('-inf'), float('inf'))
    if dark_magic_cost != 0:
        left_magic_score = max(score_values[0:4]) - dark_magic_cost
        right_magic_score = max(score_values[4:8]) - dark_magic_cost
    else:
        left_magic_score = float('-inf')
        right_magic_score = float('-inf')

    optimal_score = max(basic_minimax, left_magic_score, right_magic_score)

    if optimal_score == left_magic_score:
        print(f'The updated minimax value is {left_magic_score}. Pacman moves left and uses dark magic.')
    elif optimal_score == right_magic_score:
        print(f'The updated minimax value is {right_magic_score}. Pacman moves right and uses dark magic.')
    else:
        print(f"The minimax value is {basic_minimax}. Pacman decides not to use dark magic.")

pacman_decision(int(input("Enter cost of dark magic: ")))</pre>
</body>
</html>
