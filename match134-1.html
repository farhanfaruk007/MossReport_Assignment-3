<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/4/23241033_sharthakdas_cse422_04_assignment03_fall2024_-_SHARTHAK_DAS.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/10/23141030_cse422_10_labassignment3_-_SYED_TASRIF_HASAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""23141030_CSE422_10_LabAssignment3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tvin_KlFhhXtGNXmp-lczw6gF0P4Qg00

Syed Tasrif Hasan
ID:23141030
Sec:10
"""

#Part1
import random

# Seed the random generator for consistency in output
random.seed(0)

<a name="0"></a><font color="#FF0000"><a href="match134-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

class Node:
    def __init__(self, player, depth, score=0):
        self.player = player
        self.depth = depth
        self.score = score
        self.descendants = []

def alpha_beta(node, alpha, beta, maximize):
    if node.depth == 0 or node.score != 0:  # Terminal node check
</font>        return node.score, node

    if maximize:
        max_eval = -float('inf')
        optimal_child = None
        for child in node.descendants:
            eval_score, _ = alpha_beta(child, alpha, beta, False)
            if eval_score &gt; max_eval:
                max_eval = eval_score
                optimal_child = child
            alpha = max(alpha, max_eval)
            if beta &lt;= alpha:  # Prune remaining branches
                break
        return max_eval, optimal_child
    else:
        min_eval = float('inf')
        optimal_child = None
        for child in node.descendants:
            eval_score, _ = alpha_beta(child, alpha, beta, True)
            if eval_score &lt; min_eval:
                min_eval = eval_score
                optimal_child = child
            beta = min(beta, min_eval)
            if beta &lt;= alpha:
                break
        return min_eval, optimal_child

<a name="4"></a><font color="#FF00FF"><a href="match134-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

def build_tree(start_player, depth_limit):
    root = Node(start_player, depth_limit)
    _generate_tree(root, depth_limit - 1)
    return root

def _generate_tree(node, remaining_depth):
    if remaining_depth == 0:
        node.score = random.choice([-1, 1])  # Assign random utility to leaf nodes
</font><a name="2"></a><font color="#0000FF"><a href="match134-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

        return

    for _ in range(2):  # Binary branching
        child = Node(1 - node.player, remaining_depth - 1)
        node.descendants.append(child)
        _generate_tree(child, remaining_depth - 1)

def play_game(starting_player):
    depth_limit = 5

    round_results = []
</font>    active_player = starting_player
    total_rounds = 0

    while total_rounds &lt; 3:  # Play three rounds
        game_tree = build_tree(active_player, depth_limit)
        utility, _ = alpha_beta(game_tree, -float('inf'), float('inf'), active_player == 1)

        if utility == -1:
            round_results.append("Scorpion")
        else:
            round_results.append("Sub-Zero")

        active_player = 1 - active_player  # Alternate between players
        total_rounds += 1

    final_winner = round_results[-1]
    return final_winner, total_rounds, round_results

# Input and game execution
start_player = int(input())
winner, rounds, results = play_game(start_player)

print("Game Winner:", winner)
print("Total Rounds Played:", rounds)
for idx, result in enumerate(results):
    print(f"Winner of Round {idx + 1}: {result}")

#part2
class TreeNode:
    def __init__(self, data, descendants=None):
        self.data = data
        if descendants is None:
            self.descendants = []
        else:
            self.descendants = descendants

def alpha_beta(node, alpha, beta, is_maximizing):
    # Base case: if the node is a leaf node, return its value
    if not node.descendants:
<a name="1"></a><font color="#00FF00"><a href="match134-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

        return node.data

    if is_maximizing:
        best_score = -float('inf')
        for child in node.descendants:
            best_score = max(best_score, alpha_beta(child, alpha, beta, False))
            alpha = max(alpha, best_score)
            if beta &lt;= alpha:  # Prune the branch
                break
        return best_score
    else:
        best_score = float('inf')
</font>        for child in node.descendants:
<a name="3"></a><font color="#00FFFF"><a href="match134-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

            best_score = min(best_score, alpha_beta(child, alpha, beta, True))
            beta = min(beta, best_score)
            if beta &lt;= alpha:  # Prune the branch
                break
        return best_score

def play_pacman(modifier):
    # Construct the game tree
    root = TreeNode(0)
    root.descendants = [TreeNode(0), TreeNode(0)]
</font>    root.descendants[0].descendants = [TreeNode(3), TreeNode(6)]
    root.descendants[1].descendants = [TreeNode(2), TreeNode(7), TreeNode(1), TreeNode(2), TreeNode(0)]

    # Run the alpha-beta pruning algorithm
    minimax_result = alpha_beta(root, -float('inf'), float('inf'), True)

    # Compare the minimax value to the modified threshold
    if minimax_result &lt; 7 - modifier:
        return f"The new minimax value is {7 - modifier}. Pacman goes right and uses dark magic"
    else:
        return f"The minimax value is {minimax_result}. Pacman does not use dark magic"

# Test the function with different modifiers
print(play_pacman(2))
print(play_pacman(5))</pre>
</body>
</html>
