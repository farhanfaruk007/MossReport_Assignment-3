<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/21301035_omar_08_-_OMAR_NASIF_CHOWDHURY.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/21301035_omar_08_-_OMAR_NASIF_CHOWDHURY.py<p></p><pre>
# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rioSwpoug28jzC6u2d94KHciWpH851TX
"""

<a name="0"></a><font color="#FF0000"><a href="match173-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_14.gif"/></a>

class MortalKombat:
    def __init__(self, starting_player):
        self.starting_player = starting_player
        self.branching_factor = 2
        self.max_depth = 5

    def alpha_beta_pruning(self, depth, alpha, beta, is_maximizing):
        if depth == self.max_depth:
            return 1 if is_maximizing else -1
        if is_maximizing:
            max_eval = float('-inf')
            for i in range(self.branching_factor):
                eval = self.alpha_beta_pruning(depth + 1, alpha, beta, False)
                max_eval = max(max_eval, eval)
                alpha = max(alpha, eval)
                if beta &lt;= alpha:
                    break
            return max_eval
        else:
            min_eval = float('inf')
            for i in range(self.branching_factor):
                eval = self.alpha_beta_pruning(depth + 1, alpha, beta, True)
                min_eval = min(min_eval, eval)
                beta = min(beta, eval)
                if beta &lt;= alpha:
</font>                    break
            return min_eval

    def simulate_game(self):
        rounds = 3
        results = []
        for i in range(rounds):
            winner = self.alpha_beta_pruning(0, float('-inf'), float('inf'), self.starting_player == 0)
            results.append("Scorpion" if winner == -1 else "Sub-Zero")
            self.starting_player = 1 - self.starting_player

        game_winner = max(set(results), key=results.count)
        return {
            "Game Winner": game_winner,
            "Total Rounds Played": rounds,
            "Winners Per Round": results
        }

starting_player = 1
game = MortalKombat(starting_player)
result = game.simulate_game()

print(f"Game Winner: {result['Game Winner']}")
print(f"Total Rounds Played: {result['Total Rounds Played']}")
for idx, winner in enumerate(result["Winners Per Round"], 1):
    print(f"Winner of Round {idx}: {winner}")

<a name="1"></a><font color="#00FF00"><a href="match173-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

class PacmanGame:
    def __init__(self):
        self.initial_values = [3, 6, 2, 3, 7, 1, 2, 0]

    def minimax(self, values, depth, is_maximizing, alpha, beta):
</font>        if depth == 3:
            return values.pop(0)

        if is_maximizing:
            max_eval = float('-inf')
            for _ in range(2):
                eval = self.minimax(values[:], depth + 1, False, alpha, beta)
                max_eval = max(max_eval, eval)
                alpha = max(alpha, eval)
                if beta &lt;= alpha:
                    break
            return max_eval
        else:
            min_eval = float('inf')
            for _ in range(2):
                eval = self.minimax(values[:], depth + 1, True, alpha, beta)
                min_eval = min(min_eval, eval)
                beta = min(beta, eval)
                if beta &lt;= alpha:
                    break
            return min_eval

    def play_game(self, magic_cost):
        root_value = self.minimax(self.initial_values[:], 0, True, float('-inf'), float('inf'))
        left_magic = max(self.initial_values[:4]) - magic_cost
        right_magic = max(self.initial_values[4:]) - magic_cost

        return {
            "Without Dark Magic": root_value,
            "Left Magic Strategy": left_magic,
            "Right Magic Strategy": right_magic,
            "Best Strategy": "Right Magic" if right_magic &gt; left_magic else "Left Magic"
        }


magic_cost = 5
game = PacmanGame()
result = game.play_game(magic_cost)

print(f"Without Dark Magic: {result['Without Dark Magic']}")
print(f"Left Magic Strategy Value: {result['Left Magic Strategy']}")
print(f"Right Magic Strategy Value: {result['Right Magic Strategy']}")
print(f"Best Strategy: {result['Best Strategy']}")

class TreeNode:
    def __init__(self, value=None):
        self.value = value
        self.children = []

def create_game_tree():
    leaf_values = [3, 6, 2, 3, 7, 1, 2, 0]
    leaves = [TreeNode(value=v) for v in leaf_values]

    intermediate = []
    for i in range(0, len(leaves), 2):
        node = TreeNode()
        node.children = [leaves[i], leaves[i + 1]]
        intermediate.append(node)

    second_level = []
    for i in range(0, len(intermediate), 2):
        node = TreeNode()
        node.children = [intermediate[i], intermediate[i + 1]]
        second_level.append(node)

    root = TreeNode()
    root.children = second_level
    return root

def alpha_beta_pruning(node, alpha, beta, depth, is_maximizing):
    if depth == 0 or not node.children:
        return node.value

    if is_maximizing:
        max_value = float('-inf')
        for child in node.children:
            val = alpha_beta_pruning(child, alpha, beta, depth - 1, False)
            max_value = max(max_value, val)
            alpha = max(alpha, val)
            if beta &lt;= alpha:
                break
        return max_value
    else:
        min_value = float('inf')
        for child in node.children:
            val = alpha_beta_pruning(child, alpha, beta, depth - 1, True)
            min_value = min(min_value, val)
            beta = min(beta, val)
            if beta &lt;= alpha:
                break
        return min_value

def pacman_strategy(cost):
    root = create_game_tree()
    root_value = alpha_beta_pruning(root, float('-inf'), float('inf'), 3, True)
    left_child, right_child = root.children
    left_max = max(
        alpha_beta_pruning(left_child.children[0], float('-inf'), float('inf'), 1, True),
        alpha_beta_pruning(left_child.children[1], float('-inf'), float('inf'), 1, True)
    )
    right_max = max(
        alpha_beta_pruning(right_child.children[0], float('-inf'), float('inf'), 1, True),
        alpha_beta_pruning(right_child.children[1], float('-inf'), float('inf'), 1, True)
    )

    left_magic_value = left_max - cost
    right_magic_value = right_max - cost

    if right_magic_value &gt; left_magic_value:
        best_value = right_magic_value
        direction = "right"
    else:
        best_value = left_magic_value
        direction = "left"

    print(f"C1: {cost}")
    print(f"C2: {root_value}")
    if best_value &gt; root_value:
        print(f"The new minimax value is {best_value} . Pacman goes {direction} and uses dark magic.")
    else:
        print(f"The minimax value is {root_value} . Pacman does not use dark magic.")
pacman_strategy(2)
pacman_strategy(5)</pre>
</body>
</html>
