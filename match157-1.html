<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/4/20301313_04_NURSHIDA_AKTER_NILIMA.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/4/20301313_cse422_lab3_NURSHIDA_AKTER_NILIMA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""CSE422_Lab3_20301313

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HEWpDUVpatJmkMAhW1I_Kur2-qnHUg1T
"""

#Part1


def alpha_beta_pruning_mk(node, depth, alpha, beta, maximizing_player):
    """
    node: current node being evaluated (0 for Scorpion, 1 for Sub-Zero)
    depth: current depth of the search
    alpha: the best score for the maximizing player
    beta: the best score for the minimizing player
    maximizing_player: Boolean, True if maximizing player's turn (Sub-Zero), False if minimizing player's turn (Scorpion)
    """

    if depth == 0:
        return node

    if maximizing_player:
        max_eval = float('-inf')
        for child in [0, 1]:
            eval = alpha_beta_pruning_mk(child, depth - 1, alpha, beta, False)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for child in [0, 1]:
            eval = alpha_beta_pruning_mk(child, depth - 1, alpha, beta, True)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break
        return min_eval


def mortal_kombat_battle(first_player):
    rounds = 0
    winner_per_round = []
    current_player = first_player


    while rounds &lt; 3:
        rounds += 1
        alpha = float('-inf')
        beta = float('inf')
        maximizing_player = (current_player == 1)
        winner = alpha_beta_pruning_mk(current_player, 5, alpha, beta, maximizing_player)

        if winner == 1:
            winner_per_round.append("Sub-Zero")
        else:
            winner_per_round.append("Scorpion")


        current_player = 1 - current_player


    if winner_per_round.count("Scorpion") &gt; winner_per_round.count("Sub-Zero"):
        game_winner = "Scorpion"
    else:
        game_winner = "Sub-Zero"

    return game_winner, rounds, winner_per_round



if __name__ == "__main__":

    first_player = int(input())


    game_winner, total_rounds, winner_per_round = mortal_kombat_battle(first_player)


    print(f"GameWinner: {game_winner}")
    print(f"Total Rounds Played: {total_rounds}")
    for i in range(total_rounds):
        print(f"Winner of Round {i+1}: {winner_per_round[i]}")

#part 2

leaf_values = [3, 6, 2, 3, 7, 1, 2, 0]


def alpha_beta_pruning(depth, node_index, maximizing_player, alpha, beta, tree):
    if depth == 2:
        return tree[node_index]

    if maximizing_player:
        max_eval = float('-inf')
        for i in range(2):
            eval = alpha_beta_pruning(depth + 1, node_index * 2 + i, False, alpha, beta, tree)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta &lt;= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for i in range(2):
            eval = alpha_beta_pruning(depth + 1, node_index * 2 + i, True, alpha, beta, tree)
<a name="0"></a><font color="#FF0000"><a href="match157-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_28.gif"/></a>

            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta &lt;= alpha:
                break
        return min_eval


def pacman_game(c):

    tree_no_magic = leaf_values
    root_value_no_magic = alpha_beta_pruning(0, 0, True, float('-inf'), float('inf'), tree_no_magic)


    tree_with_magic_left = [
        max(tree_no_magic[0], tree_no_magic[1]),
        max(tree_no_magic[2], tree_no_magic[3]),
    ]
    tree_with_magic_right = [
        max(tree_no_magic[4], tree_no_magic[5]),
        max(tree_no_magic[6], tree_no_magic[7])
    ]


    tree_with_magic_left[0] -= c
    tree_with_magic_left[1] -= c
    tree_with_magic_right[0] -= c
    tree_with_magic_right[1] -= c


    root_value_with_magic_left = max(tree_with_magic_left[0], tree_with_magic_left[1])
    root_value_with_magic_right = max(tree_with_magic_right[0], tree_with_magic_right[1])


    root_value_with_magic = max(root_value_with_magic_left, root_value_with_magic_right)


    if root_value_with_magic &gt; root_value_no_magic:
        return f"The new minimax value is {root_value_with_magic}. Pacman goes right and uses dark magic"
    else:
        return f"The minimax value is {root_value_no_magic}. Pacman does not use dark magic"


def main():

    try:
        c = int(input("Enter the cost of dark magic (c): "))
        result = pacman_game(c)
        print(result)
    except ValueError:
        print("Please enter a valid integer value for the cost.")


if __name__ == "__main__":
</font>    main()</pre>
</body>
</html>
