<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/7/24241280_S_M_Kafi_Anam_CSE422_07_Assignment03_Fall2024.py_-_S.M_Kafi_Anam.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/15/24141085_Zabid_Rahman_Cse422_15_Assignment3_-_ZABID_RAHMAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""alpha beta.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E7b-Qi_Xo8kS_KunVBb2neI8TTRCGYef
"""

<a name="1"></a><font color="#00FF00"><a href="match26-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_27.gif"/></a>

print('Task-1')
import math

def evaluate_branch(level, node, maximize, scores, max_level, a, b):
    if level == max_level:
        return scores[node]

    if maximize:
        left_score = evaluate_branch(level + 1, node * 2, False, scores, max_level, a, b)
        right_score = evaluate_branch(level + 1, node * 2 + 1, False, scores, max_level, a, b)
        best_score = max(left_score, right_score)
        a = max(a, best_score)

        if a &gt;= b:
            return best_score
        return best_score

    else:
        left_score = evaluate_branch(level + 1, node * 2, True, scores, max_level, a, b)
        right_score = evaluate_branch(level + 1, node * 2 + 1, True, scores, max_level, a, b)
        best_score = min(left_score, right_score)
        b = min(b, best_score)

        if a &gt;= b:
            return best_score
        return best_score

def battle_simulation(first_player):
    leaf_nodes = 32
    match_scores = [1 if i % 2 == 0 else -1 for i in range(leaf_nodes)]
    depth = 5
</font>    alpha = float('-inf')
    beta = float('inf')
<a name="3"></a><font color="#00FFFF"><a href="match26-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_11.gif"/></a>

    battle_results = []
    scorpion_victories = 0
    subzero_victories = 0
    active_turn = first_player

    for match in range(3):
        final_score = evaluate_branch(0, 0, active_turn == 1, match_scores, depth, alpha, beta)
        if final_score == 1:
            winner = "Sub-Zero"
        else:
            winner = "Scorpion"

        battle_results.append(f"Winner of Match {match + 1}: {winner}")
        if winner == "Scorpion":
            scorpion_victories += 1
        else:
            subzero_victories += 1

        active_turn = 1 - active_turn
</font>
<a name="0"></a><font color="#FF0000"><a href="match26-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_32.gif"/></a>

    final_winner = "Scorpion" if scorpion_victories &gt; subzero_victories else "Sub-Zero"

    print(f"Champion: {final_winner}")
    print(f"Total Matches: 3")
    for result in battle_results:
        print(result)

player = int(input("Who starts? (0 for Scorpion, 1 for Sub-Zero): "))
if player in [0, 1]:
    battle_simulation(player)
else:
    print("Invalid choice")


print("Task-2")

def strategic_evaluation(step, pos, is_max, values, limit, alpha, beta):
    if step == limit:
        return values[pos]

    if is_max:
        left = strategic_evaluation(step + 1, pos * 2, False, values, limit, alpha, beta)
        right = strategic_evaluation(step + 1, pos * 2 + 1, False, values, limit, alpha, beta)
        optimal = max(left, right)
        alpha = max(alpha, optimal)
        if alpha &gt;= beta:
            return optimal
        return optimal

    else:
        left = strategic_evaluation(step + 1, pos * 2, True, values, limit, alpha, beta)
        right = strategic_evaluation(step + 1, pos * 2 + 1, True, values, limit, alpha, beta)
        optimal = min(left, right)
        beta = min(beta, optimal)
        if alpha &gt;= beta:
            return optimal
        return optimal

def pacman_challenge(magic_cost):
    data = [3, 6, 2, 3, 7, 1, 2, 0]
    total_nodes = len(data)
    depth_limit = int(math.log2(total_nodes))
</font>    alpha = float('-inf')
    beta = float('inf')

<a name="2"></a><font color="#0000FF"><a href="match26-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_15.gif"/></a>

    base_score = strategic_evaluation(0, 0, True, data, depth_limit, alpha, beta)

    left_tree_max = max(
        strategic_evaluation(2, 0, True, data, depth_limit, alpha, beta),
        strategic_evaluation(2, 1, True, data, depth_limit, alpha, beta)
    )
    left_magic_score = left_tree_max - magic_cost

    right_tree_max = max(
        strategic_evaluation(2, 2, True, data, depth_limit, alpha, beta),
        strategic_evaluation(2, 3, True, data, depth_limit, alpha, beta)
    )
    right_magic_score = right_tree_max - magic_cost

    if max(left_magic_score, right_magic_score) &gt; base_score:
        if right_magic_score &gt;= left_magic_score:
            print(f"New score: {right_magic_score}. Pacman moves right and uses dark magic.")
        else:
            print(f"New score: {left_magic_score}. Pacman moves left and uses dark magic.")
    else:
        print(f"Score remains: {base_score}. Pacman avoids dark magic.")

magic_cost = int(input("Cost of using dark magic: "))
pacman_challenge(magic_cost)</font></pre>
</body>
</html>
