<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/22101094_sec08_lab3_(1)_-_SABAHA_SADIK.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/15/22101311_md_tanvirul_islam_rifat_cse422_15_lab_assignment03_fall2024__-_MD.TANVIRUL_ISLAM_RIFAT.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101311_Md. Tanvirul Islam Rifat_CSE422_15_Lab_Assignment03_Fall2024 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XKi6HOwhk5sCntNinBdD-_uQzsyUBI8z
<a name="1"></a><font color="#00FF00"><a href="match148-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

"""

#Task-1
import secrets

class MortalKombatGame:
    def __init__(self, first_fighter):
        self.first_fighter= first_fighter
        self.second_fighter =1 -first_fighter
        self.round_winners=[]
</font>        self.total_rounds=0


    def game(self):
        current_fighter = self.first_fighter

        for i in range(3):
            round_result =self.round_play(current_fighter)
            if round_result==1:
                winner="Sub-Zero"
            else:
                winner="Scorpion"
            self.round_winners.append(winner)
            current_fighter = 1-current_fighter
            self.total_rounds+= 1

        self.final_result()


    def round_play(self,current_fighter):
        return self.alpha_beeta_pruning(current_fighter,0,float('-inf'),float('inf'), True)

<a name="2"></a><font color="#0000FF"><a href="match148-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

    def alpha_beeta_pruning(self,current_fighter,depth,alpha,beeta,maximizing_turn):
      if depth==5:
          return secrets.choice([-1,1])

      if maximizing_turn:
          max_score =float('-inf')
</font>          i= 0
          while i&lt;2:
              score = self.alpha_beeta_pruning(1-current_fighter,depth+ 1,alpha,beeta, False)
              max_score =max(max_score, score)
              alpha =max(alpha, score)
              if alpha &gt;=beeta:
                  break
              i += 1
          return max_score
      else:
          min_score=float('inf')
          i = 0
          while i&lt;2:
              score = self.alpha_beeta_pruning(1-current_fighter,depth+1,alpha,beeta, True)
              min_score =min(min_score,score)
              beeta =min(beeta, score)
              if alpha &gt;=beeta:
                  break
              i += 1
          return min_score

    def final_result(self):
        subzero_win =self.round_winners.count("Sub-Zero")
        scorpion_win =self.round_winners.count("Scorpion")

        if subzero_win &gt;scorpion_win:
            game_winner="Sub-Zero"
        else:
            game_winner="Scorpion"

        print(f"Winner: {game_winner}")
        print(f"Total Rounds: {self.total_rounds}")
        for i in range(len(self.round_winners)):
            print(f"Winner of Round {i+1}: {self.round_winners[i]}")

first_fighter= int(input('Enter 0 for Scorpion, 1 for Sub-Zero): '))
battle_game = MortalKombatGame(first_fighter)
battle_game.game()

#Task-2
def evalute_game(current_depth,is_maximizing_player,score,alpha, beeta):
    if current_depth== 2:
        return score
    if is_maximizing_player == True:
        max_value= float('-inf')
        i=0
        while i&lt;len(score):
            evaluation =evalute_game(current_depth+1,False,score[i],alpha,beeta)
            max_value = max(max_value,evaluation)
            alpha =max(alpha,evaluation)
            if beeta &lt;= alpha:
                break
            i+=1
        return max_value
    else:
        min_value=float('inf')
        i=0
        while i&lt;len(score):
            evaluation =evalute_game(current_depth + 1, True, score[i], alpha, beeta)
            min_value =min(min_value, evaluation)
            beeta =min(beeta, evaluation)
            if beeta &lt;= alpha:
                break
            i+=1
<a name="0"></a><font color="#FF0000"><a href="match148-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_21.gif"/></a>

        return min_value

# pacman_strategy
def pacman_strategy(cost):
    def calculate_potential_score_with_dark_magic(score,cost):
        left_score_with_magic = max(score[0])- cost
        right_score_with_magic = max(score[2])- cost
        return left_score_with_magic,  right_score_with_magic

    def determine_best_move(root_value, score_with_magic):
        if score_with_magic[0] &gt;score_with_magic[1]:
            new_minimax_value =score_with_magic[0]
            direction = "left"
        else:
            new_minimax_value =score_with_magic[1]
            direction = "right"

        if new_minimax_value &gt;  root_value:
            print(f"The new minimax value is {new_minimax_value}. Pacman goes {direction} and uses dark magic.")
        else:
            print(f"The minimax value is {root_value}. Pacman does not use dark magic.")

    score = [[3,6],[2,3],[7,1],[2,0]]
    root_value = evalute_game(0,True,score,float('-inf'),float('inf'))
    score_with_magic = calculate_potential_score_with_dark_magic(score, cost)
    determine_best_move(root_value, score_with_magic)

if __name__ == "__main__":
    cost = int(input("Enter the cost: "))
    pacman_strategy(cost)</font></pre>
</body>
</html>
