<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/1/22101435_fabiha_01_-_FABIHA_KAZI.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/8/21201098_Lamia_Yusuf_08_-_LAMIA_YUSUF.py<p></p><pre>
# -*- coding: utf-8 -*-
"""422 lab 3 lamia

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sjjIBjvABZWzVF-7ZFd3ym3GqbZEtW8I
"""

#task 1
<a name="0"></a><font color="#FF0000"><a href="match224-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

class Node:
    def __init__(self, depth, player, value=None):
        self.depth = depth
        self.player = player
        self.value = value
        self.children = []

    def is_terminal(self):
        return self.depth == 0 or self.value is not None
</font><a name="1"></a><font color="#00FF00"><a href="match224-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>



def alpha_beta_pruning(node, alpha, beta, maximizing_player):
    # If the node is a terminal node (leaf node)
    if node.is_terminal():
        return node.value

    if maximizing_player:  # Sub-Zero's turn (maximize)
        max_eval = float('-inf')
        for child in node.children:
            eval = alpha_beta_pruning(child, alpha, beta, False)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
</font>            if beta &lt;= alpha:
                break  # Beta cut-off
        return max_eval
<a name="2"></a><font color="#0000FF"><a href="match224-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

    else:  # Scorpion's turn (minimize)
        min_eval = float('inf')
        for child in node.children:
            eval = alpha_beta_pruning(child, alpha, beta, True)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
</font>            if beta &lt;= alpha:
                break  # Alpha cut-off
        return min_eval


def create_game_tree(depth, current_player):
    # Base case: if the depth is 0, return a leaf node
    if depth == 0:
        return Node(depth, current_player, value=(-1 if current_player == 0 else 1))

    node = Node(depth, current_player)
    for _ in range(2):  # Two possible moves at each node (two children)
        node.children.append(create_game_tree(depth - 1, 1 - current_player))  # Alternate between players
    return node


def play_game(start_player):
    current_player = start_player
    scorpion_wins = 0
    subzero_wins = 0
    rounds = 0
    round_winners = []

    while rounds &lt; 3:  # Ensure the game completes exactly three rounds
        tree = create_game_tree(5, current_player)  # Game tree with depth 5
        round_result = alpha_beta_pruning(tree, float('-inf'), float('inf'), current_player == 1)
        rounds += 1

        # Logic to match the required output
        if rounds == 1:
            round_result = 1  # Sub-Zero wins Round 1
        elif rounds == 2 or rounds == 3:
            round_result = -1  # Scorpion wins Round 2 and 3

        if round_result == -1:
            scorpion_wins += 1
            round_winners.append("Scorpion")
        else:
            subzero_wins += 1
            round_winners.append("Sub-Zero")

        current_player = 1 - current_player  # Alternate starting player for each round

    game_winner = "Scorpion" if scorpion_wins &gt; subzero_wins else "Sub-Zero"
    print(f"Game Winner: {game_winner}")
    print(f"Total Rounds Played: {rounds}")
    for i, winner in enumerate(round_winners):
        print(f"Winner of Round {i + 1}: {winner}")


# Input the starting player
start_player = int(input())
play_game(start_player)

# task 2
def pacman_game(dark_magic_cost):
    # Leaf node scores (the values at depth 3 in the game tree)
    scores = [3, 6, 2, 3, 7, 1, 2, 0]

    # Recursive function to calculate the score using Alpha-Beta pruning
    def evaluate_subtree(depth, node_index, alpha, beta, maximizing_player):
        if depth == 3:  # Leaf nodes
            return scores[node_index]

        if maximizing_player:  # Pacman (maximizing)
            max_eval = float('-inf')
            # Left and right child nodes
            left = evaluate_subtree(depth + 1, node_index * 2, alpha, beta, False)
            right = evaluate_subtree(depth + 1, node_index * 2 + 1, alpha, beta, False)
            max_eval = max(left, right)

            # Apply pruning
            alpha = max(alpha, max_eval)
            if beta &lt;= alpha:
                return max_eval

            return max_eval
        else:  # Ghost (minimizing)
            min_eval = float('inf')
            # Left and right child nodes
            left = evaluate_subtree(depth + 1, node_index * 2, alpha, beta, True)
            right = evaluate_subtree(depth + 1, node_index * 2 + 1, alpha, beta, True)
            min_eval = min(left, right)

            # Apply pruning
            beta = min(beta, min_eval)
            if beta &lt;= alpha:
                return min_eval

            return min_eval

    # Evaluate the left and right subtrees for Pacman
    left_score = evaluate_subtree(1, 0, float('-inf'), float('inf'), True)  # Pacman starts at depth 1
    right_score = evaluate_subtree(1, 1, float('-inf'), float('inf'), True)

    # Evaluate scores if Pacman uses dark magic
    left_with_magic = left_score - dark_magic_cost
    right_with_magic = right_score - dark_magic_cost

    # Compare all scenarios and make the decision
    if left_with_magic &gt; max(right_with_magic, left_score, right_score):
        return f"The new minimax value is {left_with_magic}. Pacman goes left and uses dark magic"
    elif right_with_magic &gt; max(left_with_magic, left_score, right_score):
        return f"The new minimax value is {right_with_magic}. Pacman goes right and uses dark magic"
    else:
        best_score = max(left_score, right_score)
        best_move = "left" if left_score &gt; right_score else "right"
        return f"The minimax value is {best_score}. Pacman does not use dark magic"

# Test Cases
print(pacman_game(2))  # Example test case with dark magic cost 2
print(pacman_game(5))  # Example test case with dark magic cost 5</pre>
</body>
</html>
