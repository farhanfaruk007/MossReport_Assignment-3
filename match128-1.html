<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/12/21201590_md_jadid_hossain_sanim_cse422_12_assignment03_fall2024_-_MD._JADID_HOSSAIN_SANIM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/13/21101071_422_lab3_-_MRIDUL_MUNTASIR_HAQUE.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21101071_422_Lab3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1odt679wc2nIUDzLtsKoFHRSDFbNvFPmj
"""

#Task 1
result_tree = []
p_tracker = 0
while p_tracker &lt; 32:
    result_tree.append(-1 if p_tracker % 2 != 0 else 1)
<a name="1"></a><font color="#00FF00"><a href="match128-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

    p_tracker += 1

def decide_best_move(tree_position, current_leaf_, alpha_limit, beta_limit, is_max_turn):
    if current_leaf_ == 0:
        return result_tree[tree_position]
    if is_max_turn:
        highest_outcome = float('-inf')
</font>        move_count = 0
        while move_count &lt; 2:
<a name="2"></a><font color="#0000FF"><a href="match128-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

            evaluated_outcome = decide_best_move(tree_position * 2 + move_count, current_leaf_ - 1, alpha_limit, beta_limit, False)
            highest_outcome = max(highest_outcome, evaluated_outcome)
            alpha_limit = max(alpha_limit, highest_outcome)
            if beta_limit &lt;= alpha_limit:
                break
            move_count += 1
</font>        return highest_outcome
    else:
        lowest_outcome = float('inf')
        move_count = 0
        while move_count &lt; 2:
<a name="0"></a><font color="#FF0000"><a href="match128-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_26.gif"/></a>

            evaluated_outcome = decide_best_move(tree_position * 2 + move_count, current_leaf_ - 1, alpha_limit, beta_limit, True)
            lowest_outcome = min(lowest_outcome, evaluated_outcome)
            beta_limit = min(beta_limit, lowest_outcome)
            if beta_limit &lt;= alpha_limit:
                break
            move_count += 1
        return lowest_outcome


def battle_simulation(starting_turn):
    active_player = starting_turn
    rounds_completed = 0
    round_results = []
    scorpion_outcome = 0
    subzero_outcome = 0

    for current_round in range(3):
        round_outcome = decide_best_move(0, 5, float('-inf'), float('inf'), active_player == 1)
        if round_outcome == 1:
            subzero_outcome += 1
            round_results.append('Sub-Zero')
        else:
            scorpion_outcome += 1
            round_results.append('Scorpion')

        active_player = 1 - active_player
        rounds_completed += 1


    final_winner = 'Sub-Zero' if subzero_outcome &gt; scorpion_outcome else 'Scorpion'
    return round_results, final_winner, rounds_completed

first_turn = int(input("Select the first fighter: Enter 0 for Scorpion or 1 for Sub-Zero: "))
round_history, match_winner, total_rounds_played = battle_simulation(first_turn)


output_message = f"""Match Winner: {match_winner}
Total Rounds Fought: {total_rounds_played}
"""

round_counter = 1
for victor in round_history:
    output_message += f"Winner of Round {round_counter}: {victor}\n"
    round_counter += 1

print(output_message)
</font>

############TASK2######################################
print('TASK 2')





class pacman_game:
    def __init__(self, magic_price):
        self.input = [3, 6, 2, 3, 7, 1, 2, 0]
        self.magic_price = magic_price
        self.no_magic_price = None
        self.including_magic_price = None

    def minimax_including_alpha_beta(self, leaf_, p, maximize, alpha, beta, magic_used):
        if leaf_ == 3:
            return self.input[p]

        if maximize:
            best = float('-inf')
            pos = 0
            while pos &lt; 2:
                outcome = self.minimax_including_alpha_beta(leaf_ + 1, p * 2 + pos, False, alpha, beta, magic_used)
                if outcome &gt; best:
                    best = outcome
                alpha = max(alpha, best)
                if beta &lt;= alpha:
                    break
                pos += 1
            if magic_used:
                return best - self.magic_price
            return best
        else:
            best = float('inf')
            pos = 0
            while pos &lt; 2:
                outcome = self.minimax_including_alpha_beta(leaf_ + 1, p * 2 + pos, True, alpha, beta, magic_used)
                if outcome &lt; best:
                    best = outcome
                beta = min(beta, best)
                if beta &lt;= alpha:
                    break
                pos += 1
            return best

    def run_game(self):

        self.no_magic_price = self.minimax_including_alpha_beta(0, 0, True, float('-inf'), float('inf'), False)


        self.including_magic_price = self.minimax_including_alpha_beta(0, 0, True, float('-inf'), float('inf'), True)


        result = f"The optimal minimax outcome is {self.including_magic_price}. Pacman "
        if self.including_magic_price &gt; self.no_magic_price:
            result += " uses dark magic."
        else:
            result += "is not using dark magic."

        print(result)


if __name__ == "__main__":
    magic_price = int(input())


    game = pacman_game(magic_price)


    game.run_game()</pre>
</body>
</html>
