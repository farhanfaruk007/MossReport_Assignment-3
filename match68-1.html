<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/15/22101311_md_tanvirul_islam_rifat_cse422_15_lab_assignment03_fall2024__-_MD.TANVIRUL_ISLAM_RIFAT.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/17/24341255_s_m_mohiuddin_khan_shiam_cse422_17_assignment03_fall2024_-_S._M._MOHIUDDIN_KHAN_SHIAM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24341255_S_M_Mohiuddin_Khan_Shiam_CSE422_17_Assignment03_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F3AdB2yKp1dYGhrXv8_xzS7pDYXb6auJ
"""

# Task 1
import secrets

class MortalKombatGame:
    def __init__(self, fighter_1):
        self.fighter_1 = fighter_1  # 0 for Scorpion, 1 for Sub-Zero
        self.fighter_2 = 1 - fighter_1  # The other fighter
        print(f"First Fighter: {'Scorpion' if fighter_1 == 0 else 'Sub-Zero'}")
        self.total_rounds = 0
        self.round_winners = []

    def game(self):
        now_fighting = self.fighter_1  # first player
        # total Play of 3 rounds
        while self.total_rounds &lt; 3:
            # utitlity score  winner decide kore
            utility = self.round_play(now_fighting)
            # round er winner ke ta decide kore
            winner = "Sub-Zero" if utility == 1 else "Scorpion"

            # Store the winner of the round
<a name="2"></a><font color="#0000FF"><a href="match68-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

            self.round_winners.append(winner)
            # Switch starting fighter for the next round
            now_fighting= 1 - now_fighting
            self.total_rounds += 1

        # final result
        self.overall_result()

    def round_play(self, now_fighting):

        return self.alpha_beta_pruning(now_fighting, 0, float('-inf'), float('inf'), True)

    def alpha_beta_pruning(self, now_fighting, depth, alpha, beta, is_maximizing_turn):
        # Base case: jdi max deoth e jay tahole 1 or -1 return
        if depth == 5:
            return secrets.choice([-1, 1])  # Random

        if is_maximizing_turn:
            max_val = float('-inf')
</font>            for i in range(2):  # Two possible moves cz branchng factr 2
                # Switch the role for the next turn (minimizing)
<a name="3"></a><font color="#00FFFF"><a href="match68-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

                val = self.alpha_beta_pruning(1 - now_fighting, depth + 1, alpha, beta, False)
                max_val = max(max_val, val)
                alpha = max(alpha, val)
                if alpha &gt;= beta:
                    break  # branch pruning
</font>            return max_val

        else:
            min_val = float('inf')
            for i in range(2):
                # Switch the role for the next turn (maximizing)
<a name="4"></a><font color="#FF00FF"><a href="match68-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

                val = self.alpha_beta_pruning(1 - now_fighting, depth + 1, alpha, beta, True)
                min_val = min(min_val, val)
                beta = min(beta, val)
                if alpha &gt;= beta:
                    break  # branch Pruning
</font>            return min_val

<a name="1"></a><font color="#00FF00"><a href="match68-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

    def overall_result(self):
        # Count the wins for each fighter
        subzero_win = self.round_winners.count("Sub-Zero")
        scorpion_win = self.round_winners.count("Scorpion")

        # Determine the overall game winner
        if subzero_win &gt; scorpion_win:
            game_winner = "Sub-Zero"
        else:
            game_winner = "Scorpion"

        # Print the overall result
        print(f"Winner: {game_winner}")
        print(f"Total Rounds : {self.total_rounds}")
        for i in range(len(self.round_winners)):
            print(f"Winner of Round {i + 1}: {self.round_winners[i]}")

# Example input and game execution
first_fighter = int(input('Enter 0 (Scorpion) or 1 (Sub-Zero): '))
battle_game = MortalKombatGame(first_fighter)
battle_game.game()

# Task 2

def evaluate_game_tree(depth, maximizing_player, potential_scores, alpha_bound, beta_bound):
    if depth == 2:
        return potential_scores

    if maximizing_player:
</font>        best_value = float('-inf')
        for score in potential_scores:
            eval = evaluate_game_tree(depth + 1, False, score, alpha_bound, beta_bound)
            best_value = max(best_value, eval)
            alpha_bound = max(alpha_bound, eval)
            if beta_bound &lt;= alpha_bound:
                break
        return best_value
    else:
        worst_value = float('inf')
        for score in potential_scores:
            eval = evaluate_game_tree(depth + 1, True, score, alpha_bound, beta_bound)
            worst_value = min(worst_value, eval)
            beta_bound = min(beta_bound, eval)
            if beta_bound &lt;= alpha_bound:
                break
<a name="0"></a><font color="#FF0000"><a href="match68-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_23.gif"/></a>

        return worst_value

# pacman_strategy.py
def pacman_strategy(cost):
    def calculate_potential_scores_with_dark_magic(potential_scores, cost):
        left_with_magic = max(potential_scores[0]) - cost
        right_with_magic = max(potential_scores[2]) - cost
        return left_with_magic, right_with_magic

    def determine_best_move(root_value, potential_scores_with_magic):
        if potential_scores_with_magic[0] &gt; potential_scores_with_magic[1]:
            new_minimax_value = potential_scores_with_magic[0]
            direction = "left"
        else:
            new_minimax_value = potential_scores_with_magic[1]
            direction = "right"

        if new_minimax_value &gt; root_value:
            print(f"The new minimax value is {new_minimax_value}. Pacman goes {direction} and uses dark magic")
        else:
            print(f"The minimax value is {root_value}. Pacman does not use dark magic")

    potential_scores = [[3, 6], [2, 3], [7, 1], [2, 0]]
    root_value = evaluate_game_tree(0, True, potential_scores, float('-inf'), float('inf'))
    potential_scores_with_magic = calculate_potential_scores_with_dark_magic(potential_scores, cost)
    determine_best_move(root_value, potential_scores_with_magic)

if __name__ == "__main__":
    cost = int(input("Enter the value of cost: "))
    pacman_strategy(cost)</font></pre>
</body>
</html>
