<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/6/22101728_rabaya_farzana_sikder_cse422_06_assignment03_fall2024_-_RABAYA_FARZANA_SIKDER.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/15/22101006_sabiha_rahman_raisa_cse422_15_lab_assignment03_fall2024_-_SABIHA_RAHMAN_RAISA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101006_Sabiha Rahman Raisa_CSE422_15_Lab_Assignment03_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p-0j2rJq5tASsQYWxduCGJl9DyaSLoYm
<a name="2"></a><font color="#0000FF"><a href="match235-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

"""

# PART1
import random

SCORPION = 0
SUB_ZERO = 1

def zalpha_pruning(glimps, depth, torg, flog, is_max_turn):
    if depth == 0 or is_silent(glimps):
</font>        return ponder_node()

    bleep_nodes = craft_children(glimps)
    if is_max_turn:
        return max_turn(bleep_nodes, depth, torg, flog)
    else:
        return min_turn(bleep_nodes, depth, torg, flog)

def is_silent(glimps):
    return glimps['depth'] == 0

def ponder_node():
    return random.choice([-1, 1])

def craft_children(glimps):
    return [{'depth': glimps['depth'] - 1}, {'depth': glimps['depth'] - 1}]

def max_turn(bleep_nodes, depth, torg, flog):
    max_zeal = float('-inf')
    for node in bleep_nodes:
        mojo = zalpha_pruning(node, depth - 1, torg, flog, False)
        max_zeal = max(max_zeal, mojo)
        torg = max(torg, mojo)
        if flog &lt;= torg:
            break

    return max_zeal

def min_turn(bleep_nodes, depth, torg, flog):
    min_zeal = float('inf')
    for node in bleep_nodes:
        mojo = zalpha_pruning(node, depth - 1, torg, flog, True)
        min_zeal = min(min_zeal, mojo)
        flog = min(flog, mojo)
        if flog &lt;= torg:
            break
    return min_zeal

def BattleOfTitans(starting_bro):
    battle_victors = []
    current_bro = starting_bro
    bleep_counter = 0

    while bleep_counter &lt; 3:
        round_winner = zalpha_pruning({'depth': 5}, 5, float('-inf'), float('inf'), current_bro)
        winner = "Scorpion" if round_winner == -1 else "Sub-Zero"
        battle_victors.append(winner)

        current_bro = SCORPION if current_bro == SUB_ZERO else SUB_ZERO
<a name="0"></a><font color="#FF0000"><a href="match235-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

        bleep_counter += 1

    ultimate_bro = max(set(battle_victors), key=battle_victors.count)

    print(f"Game Winner: {ultimate_bro}.")
    print(f"Total Rounds Played: {bleep_counter}")
    for idx, winner in enumerate(battle_victors):
        print(f"Winner of Round {idx + 1}: {winner}")

starting_bro = int(input("Enter --&gt; (0 for Scorpion, 1 for Sub-Zero): "))
BattleOfTitans(starting_bro)

# PART2
def pacman_game(c):
    nodes = [3, 6, 2, 3, 7, 1, 2, 0]

    def alpha_beta(level, index, alpha, beta, is_max_turn):
</font>        if level == 3:
            return nodes[index]

        if is_max_turn:
            return perform_max_turn(level, index, alpha, beta)
        else:
            return perform_min_turn(level, index, alpha, beta)

    def perform_max_turn(level, index, alpha, beta):
      best_value = float('-inf')
      move_counter = 0
      while move_counter &lt; 2:
          new_value = alpha_beta(level + 1, index * 2 + move_counter, alpha, beta, False)
          best_value = max(best_value, new_value)
          alpha = max(alpha, new_value)
          if beta &lt;= alpha:
              break
          move_counter += 1
      return best_value

    def perform_min_turn(level, index, alpha, beta):
      best_value = float('inf')
      move_counter = 0
      while move_counter &lt; 2:
          new_value = alpha_beta(level + 1, index * 2 + move_counter, alpha, beta, True)
          best_value = min(best_value, new_value)
          beta = min(beta, new_value)
          if beta &lt;= alpha:
              break
          move_counter += 1
      return best_value


    root_value = alpha_beta(0, 0, float('-inf'), float('inf'), True)

    mid_index = len(nodes) // 2
    left_subtree_magic = max(nodes[:mid_index]) - c
    right_subtree_magic = max(nodes[mid_index:]) - c


    if max(left_subtree_magic, right_subtree_magic) &gt; root_value:
        if left_subtree_magic &gt; right_subtree_magic:
            print("The new minimax value is ",left_subtree_magic," Pacman goes left and uses dark magic.")
        else:
            print(f"The new minimax value is ",right_subtree_magic," Pacman goes right and uses dark magic.")
    else:
<a name="1"></a><font color="#00FF00"><a href="match235-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

        print(f"The minimax value is ",root_value," Pacman does not use dark magic.")

    print(f"Root Node: {root_value}.")
    if left_subtree_magic &gt; root_value or right_subtree_magic &gt; root_value:
        if right_subtree_magic &gt; left_subtree_magic:
            print("the right direction is more advantageous for Pacman using dark magic.")
        else:
            print(" the left direction is more advantageous for Pacman Using dark magic .")
    else:
        print("Using dark magic is not advantageous for Pacman.")


c_value = int(input("c: "))
</font>pacman_game(c_value)

</pre>
</body>
</html>
