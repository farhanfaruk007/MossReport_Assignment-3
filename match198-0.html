<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/11/21201009_md__nafizur_rahman_bhuiya_cse422_11_lab_assignment_3_fall2024_-_MD._NAFIZUR_RAHMAN_BHUIYA.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/11/21201009_md__nafizur_rahman_bhuiya_cse422_11_lab_assignment_3_fall2024_-_MD._NAFIZUR_RAHMAN_BHUIYA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201009_Md._Nafizur_Rahman_Bhuiya_CSE422_11_Lab_Assignment_3_fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18vPI9IljaMrNAcJydy03vkvRYuTSLQ16
"""

#Part-1

import random
import sys

def create_tree():
  branching_factor = 2
  max_depth = 5
  size = branching_factor ** max_depth
  #print(size)

  tree_val = []
  for i in range(size):
    tree_val.append(random.choice([-1, 1]))

  #print(tree_val)
  return tree_val

def alpha_beta_prun(tree_position, depth, alpha, beta, max_player, tree_val):
  if depth == 0:
    return tree_val[tree_position]

<a name="2"></a><font color="#0000FF"><a href="match198-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

  if max_player == True:
    maxeval = float('-inf')
    c_pos = 0

    while c_pos &lt; 2:
      eval = alpha_beta_prun(tree_position * 2 + c_pos, depth - 1, alpha, beta, False, tree_val)
</font><a name="0"></a><font color="#FF0000"><a href="match198-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_8.gif"/></a>

      maxeval = max(maxeval, eval)
      alpha = max(alpha, maxeval)
      if alpha &gt;= beta:
        break
      c_pos += 1

    return maxeval

  else:
    mineval = float('inf')
    c_pos = 0
    while c_pos &lt; 2:
      eval = alpha_beta_prun(tree_position * 2 + c_pos,depth - 1,alpha,beta,True,tree_val)
</font><a name="1"></a><font color="#00FF00"><a href="match198-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

      mineval = min(mineval, eval)
      beta = min(beta, mineval)
      if alpha &gt;= beta:
        break
      c_pos += 1

    return mineval

def battle(start):
  c_player = start
</font>  scorpion_win = 0
  subzero_win = 0
  round_results = []
  rounds_completed = 0
  total_rounds = 3

  for i in range(total_rounds):
    tree_val = create_tree()
    round_outcome = alpha_beta_prun(0, 5, float('-inf'), float('inf'), c_player == 1, tree_val)
    if round_outcome == 1:
      subzero_win += 1
      round_results.append('Sub-Zero')
    else:
      scorpion_win += 1
      round_results.append('Scorpion')
<a name="3"></a><font color="#00FFFF"><a href="match198-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

    c_player = 1 - c_player
    rounds_completed += 1

  if subzero_win &gt; scorpion_win:
    final_winner = 'Sub-Zero'
  else:
    final_winner = 'Scorpion'

  return round_results, final_winner, rounds_completed

f_move = int(input("Enter 0 for Scorpion or 1 for Sub-Zero: "))
</font>if f_move not in (0, 1):
  print("Invalid input. Please enter 0 or 1.")
  sys.exit()

run = battle(f_move)
c_winner = run[0]
match_winner = run[1]
total_rounds_played = run[2]

print(f"Match Winner: {match_winner}")
print(f"Total Rounds Fought: {total_rounds_played}")

round_num = 1
for i in c_winner:
  print(f"Winner of Round {round_num}: {i}")
  round_num += 1

#Part-2

def alpha_beta_prun(tree_position, depth, alpha, beta, max_player, tree_val):
  if depth == 0:
    return tree_val[tree_position]

  if max_player == True:
    maxeval = float('-inf')
    c_pos = 0

    while c_pos &lt; 2:
      eval = alpha_beta_prun(tree_position * 2 + c_pos, depth - 1, alpha, beta, False, tree_val)
      maxeval = max(maxeval, eval)
      alpha = max(alpha, maxeval)
      if alpha &gt;= beta:
        break
      c_pos += 1

    return maxeval

  else:
    mineval = float('inf')
    c_pos = 0
    while c_pos &lt; 2:
      eval = alpha_beta_prun(tree_position * 2 + c_pos,depth - 1,alpha,beta,True,tree_val)
      mineval = min(mineval, eval)
      beta = min(beta, mineval)
      if alpha &gt;= beta:
        break
      c_pos += 1

    return mineval

def pacman_game(c):
  tree_val = [3, 6, 2, 3, 7, 1, 2, 0]
  temp = len(tree_val) / 2
  slc = int(temp)

  left = tree_val[:slc]
  #print(left)
  right = tree_val[slc:]
  #print(right)
  val = alpha_beta_prun(0, 3, float('-inf'), float('inf'), True, tree_val)
  #print(val)

  l_tree = max(left)
  m_left = l_tree - c

  r_tree = max(right)
  m_right = r_tree - c

  if m_right &gt; val and m_right &gt;= m_left:
    print(f"The new minimax value is {m_right}. Pacman goes right and uses dark magic")

  elif m_left &gt; val and m_left &gt;= m_right:
    print(f"The new minimax value is {m_left}. Pacman goes left and uses dark magic")

  else:
    print(f"The minimax value is {val}. Pacman does not use dark magic")

run = input("Enter dark magic cost: ")
run = int(run)
pacman_game(run)</pre>
</body>
</html>
