<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/10/24241375_cse422_section10_labassignment3_-_MUNIRA_RAWSHAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/10/24241375_cse422_section10_labassignment3_-_MUNIRA_RAWSHAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24241375_CSE422_Section10_LabAssignment3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ENc-pd-F33h0Btk_EQAuzFDMhM4aL_gR
"""

import random
branching_factor = 2  #here each of the node has 2 children
scorpion = -1  #the value for scorpion which basically represents loss for sub-zero
subzero = 1  #the value for sub-zero represents win for sub-zero
maximum_depth = 5
#here to question the user who starts the game
gamer_info= input("Please entry who will start(0/1):")
gamer_info = int(gamer_info)  #integer form
if gamer_info == 0:
  maximumplayer = False  #scorpion starts as the minimizer
else:
  maximumplayer = True  #sub-zero starts as the maximizer
<a name="5"></a><font color="#FF0000"><a href="match135-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

total_rounds = (maximum_depth + 1) // 2
leaf = [random.choice([scorpion, subzero]) for j in range(2**maximum_depth)]

#generating random values for the leaf nodes here
alpha = float('-infinity')  #initializing alpha to the smallest possible value
</font>beta = float('infinity')  #initializing beta to the biggest possible value
node_children = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14]]
#tell which nodes are children of each parent node (partial tree mapping)

#Alpha-beta pruning
def prunning(maximumplayer, beta, alpha, depth, node):
  leafs = [random.choice([scorpion, subzero]) for j in range(2**5)]  #generating leaf values and making sure that it shouldnot be inside the function
<a name="2"></a><font color="#0000FF"><a href="match135-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

  if depth == maximum_depth:
    return leaf[node]  #return the value at a leaf if it's the bottom of the tree
  if maximumplayer:
    maximum = float('-inf')
    for a in node_children[node]:
      new_val = prunning(False, beta, alpha, depth - 1, j)
</font>      num_maximum = max(new_val, maximum)  #here the new maximum value will be updated
<a name="3"></a><font color="#00FFFF"><a href="match135-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

      alpha = max(alpha, new_val)  # updating alpha
      if alpha &gt;= beta:  #if pruning condition is met, then end the searching
        break
    return num_maximum

  else:  #if it's the Minimizer's turn (Scorpion)
    minimum = float('inf')
    for a in node_children[node]:
      new_val = prunning(True, beta, alpha, depth - 1, j)  #its a recursive call for Maximizer
</font>      num_minimum = min(new_val, minimum)
      beta = min(beta, new_val)
<a name="4"></a><font color="#FF00FF"><a href="match135-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

      if alpha &gt;= beta:  #if pruning condition is met, then end the searching
        break
      return num_minimum

#following is the function to play the game and determining the winner of each round
def round_winner(gamer_info, leafs, maximumplayer):
  player = []  # List to store the winner of each round
  for b in range(total_rounds):  # Loop through the rounds
    out = prunning(maximumplayer, float('inf'), float('-inf'), 5, 0)
    if out == 1:
</font>      r_w = 'Sub_zero'
    else:
      r_w = 'Scorpion'
      player.append(r_w)
      maximumplayer = not maximumplayer  #swwitching the player for the next round
    if len(player) &gt;= 3:  #stop here if 3 rounds are played
      break
  return player  #winners list
#play the game side by side also store the round results
x = round_winner(gamer_info, leaf, maximumplayer)
Scorpion = 0
for b in x:
  if b=='Scorpion':
    Scorpion+=1
Sub_zero = 3 - Scorpion
if Sub_zero &gt; Scorpion:
  print("Game winner: Sub_zero")
else:
  print("Game winner: Scorpion")
print('Total number of round:', total_rounds)
for b in range(total_rounds):
  print('winner of round ', b + 1, ':', x[b])  # here we will get the winner of each round

<a name="0"></a><font color="#FF0000"><a href="match135-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

index_wise_children = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12], [13, 14]]
leaf = [3, 6, 2, 3, 7, 1, 2, 0]
def alpha_prunning(maximumplayer, beta, alpha, d, n):
  if d == 3: #d is depth heree
</font>    return leaf[n]  #n is node here and if reached the maximum depth
  if maximumplayer:
    max = float('-inf')  #maximizer's initial value is negative infinity
    j = 0
    while j &lt; len(node_children[n]):
      new_value = alpha_prunning(False, beta, alpha, d - 1, node_children[n][j])
      max = max(new_value, max)
      alpha = max(alpha, new_value)
      if alpha &gt;= beta:  #its a pruning condition
        break
        j += 1
      return max
  else:
    min = float('inf')  #minimizer's initial value is positive infinity
    j = 0
    while j &lt; len(node_children[n]):
      new_value = alpha_prunning(True, beta, alpha, d - 1, node_children[n][j])
      min = min(new_value, min)
      beta = min(beta, new_value)
      if alpha &gt;= beta:
        break
        j+=1
      return min
def pacman_game(c):
  leaf=[3, 6, 2, 3, 7, 1, 2, 0]
  beta=float('inf')
  alpha=float('-inf')
  without_magicroot_value=alpha_prunning(True, float('inf'), float('-inf'), 3, 0)
  left_maximum=max(leaf[0], leaf[1], leaf[2], leaf[3])
  right_maximum=max(leaf[4], leaf[5], leaf[6], leaf[7])
<a name="1"></a><font color="#00FF00"><a href="match135-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

  left_final=left_maximum-c
  right_final=right_maximum-c
  #now a comparison of final results
  if left_final &lt; right_final:
    best=right_final
    d="Right direction"
  else:
    best=left_final
    d="Left direction"
    #Compare new value with without_magic_root_value and print results
  if best &lt; without_magicroot_value:
    print("The minimax value is", without_magicroot_value, ". Pacman does not use dark magic")
</font>  if best &gt; without_magicroot_value:
    print("The new minimax value is", best, ". Pacman goes", d, "and uses dark magic")
pacman_game(2)
pacman_game(5)</pre>
</body>
</html>
