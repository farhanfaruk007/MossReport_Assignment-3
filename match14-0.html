<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/3/22101610_priota_cse422_03_lab_assignment03_fall2024_-_PRIOTA_DAS.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/3/22101610_priota_cse422_03_lab_assignment03_fall2024_-_PRIOTA_DAS.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101610_Priota_CSE422_03_Lab_Assignment03_Fall2024.ipynb

Automatically generated by Colab.

<a name="1"></a><font color="#00FF00"><a href="match14-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

Original file is located at
    https://colab.research.google.com/drive/134HNDtndnkc4JMJuZfji__UjyvbxykAU
"""

#task1
import math
import random

def alpha_brta_algo(depth, node_index, maximizer, leaf_tree, alpha, beta):
    if depth == 5: #reach the last child (leaf node)
        return leaf_tree[node_index] #get val of leaf tree
# for max level
    if maximizer: #when turn of maximum step
</font>        max_val = -math.inf #initialising alpha as negetive infinity as maximum

        for iteration in range(2): #loop till two children
            maximized =alpha_brta_algo(depth + 1, node_index * 2 + iteration, False, leaf_tree, alpha, beta) #max_val to the max value between current max_val and val 0f child
            maximum_value = max(max_val, maximized) #update max value of node
            alpha = max(alpha, maximized) #update val of alpha in max level
            if beta &lt;= alpha: #prunning condition
                break
        return max_val
#for min level
    else:
        min_val = math.inf #initialising value of beta as infinity as mini
        for iteration in range(2):
            minimized = alpha_brta_algo(depth + 1, node_index * 2 + iteration, True, leaf_tree, alpha, beta) #min_val to the min value between current min_val and the val ofchild
            minimum_value = min(min_val, minimized) #update min value of node
            beta = min(beta, minimized) #update val of beta in min level
            if beta &lt;= alpha: #prunning condition
                break
<a name="0"></a><font color="#FF0000"><a href="match14-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_75.gif"/></a>

        return min_val


def game(player1=int(input("Enter player no:")),depth=5): #initialize round counter and determine the first player


    # true = max, false = min
    round=0
    if player1==1: # maximizer (Subzero) starts

        player=True
    else:
        player=False # minimizer (Scorpian) starts
    # keep tracking of each round winner
    winner_arr=[0,0]
    round_winner_arr=[]
    alpha_inital=-math.inf #initialising alpha as negetive infinity as maximum side
    beta_initial=math.inf #initialising value of beta as infinity as minimum side

    for _ in range(3): # for 3 round
        game_tree = []
        for _ in range(2 ** depth):
            val= random.choice([-1, 1])  # randomly choose -1 Scorpian or 1 Subzero wins
            game_tree.append(val)

        # apply Alpha-Beta Pruning to determine the winner of the round
        if player==1:
            win_player=alpha_brta_algo(depth,0,player,game_tree,alpha_inital,beta_initial)

        elif player==0:
            win_player = alpha_brta_algo(depth, 0, player, game_tree, alpha_inital, beta_initial)

        if win_player==1:
            round_winner_arr.append("subzero") #Subzero wins
            winner_arr[1] += 1 # increase his win count

        elif win_player==-1:
            round_winner_arr.append("socrpian") # Scorpian wins
            winner_arr[0] += 1 # increase his win count

        # print(round_winner_arr)
        player= not player # update  player for next round
        # print(player)

    if winner_arr[0]&gt;winner_arr[1]:
        print("Game winner: Sorpion") # Scorpian more wins
    else:
        print("Game winner: Subzero") # Subzero more win
    print(f"Total rounds played: {winner_arr[0]+winner_arr[1]}") #total played round and winner of each round
    for i in range(3):
        print(f"Winner of Round {i}: {round_winner_arr[i]}")

game()

#task 2
import math

def alpha_beta_game(node,depth_of_tree,alpha,beta,max_player): # alpha-beta pruning function
    if depth_of_tree==0: #when depth=0, leaf node
        return node.value
    if max_player: # maximizing player turn(packman)
        max_val = -math.inf #initialising alpha as negetive infinity as maximum
        for i in node.child: #child node, current node
            value = alpha_beta_game(i, depth_of_tree - 1, alpha, beta, False) # recursivly call to opponent(mini player)
            max_valu = max(max_val, value) #update max value of node
            alpha = max(alpha, value) #update val of alpha in max leve
            if beta &lt;= alpha: # prun condi
                break
        return max_val
    else:
        min_val = math.inf # minimizing players turn(oponent)
        for j in node.child: #initialising value of beta as infinity as minimum side
            value = alpha_beta_game(j, depth_of_tree - 1, alpha, beta, True) # recursivly call to maximize player
            min_val = min(min_val, value)
            beta = min(beta, value)
            if beta &lt;= alpha: # prun condi
                break
        return min_val
class NodeClass: #nodes in tree
    def __init__(self,value_of_node,child_node=[]):
        self.value=value_of_node
        self.child=child_node
def pacman_game(c):
    given_values=[3, 6, 2, 3, 7, 1, 2, 0] # values of end nodes of game tree

    leafs=[] # hold leaf nodes
    for val in given_values: # each given value create  leaf node
        leafs.append(NodeClass(val))

    level2=[] #hold level 2 nodes (have children)
    for i in range(0, len(leafs), 2):
        left_child = leafs[i]
        right_child = leafs[i + 1]
        level2.append(NodeClass(None, [left_child, right_child]))
    level1 = []
    for i in range(0, len(level2), 2):
        left_child = level2[i]
        right_child = level2[i + 1]
        level1.append(NodeClass(None, [left_child, right_child]))
    tree_root= NodeClass(None,level1)

    val_wo_magic=alpha_beta_game(tree_root,3,-math.inf,math.inf,True)
    #brings out the subtree max (Calculate "subtree maximum" values)
    Left_subMax= max(given_values[:4])-c # Left subtree's maximum value, subtracting `c`
    Right_subMax=max(given_values[4:])-c # right subtree's maximum value, subtracting `c`

    #decide pacman moves
    if Left_subMax&gt;val_wo_magic and Left_subMax-val_wo_magic&gt;=Right_subMax-val_wo_magic :
      #acman moves left and uses dark magic

        print(f"The new minimax value is {Left_subMax}. Pacman goes left and uses dark magic")
    elif Right_subMax&gt;val_wo_magic and Left_subMax-val_wo_magic&lt;=Right_subMax-val_wo_magic:
      #pacman moves right and not use dark magic
        print(f"The new minimax value is {Right_subMax}. Pacman goes right and uses dark magic")
    else: #neither subtree has better outcome Pacman does not use dark magic
        print(f"The minimax value is {val_wo_magic}. Pacman does not use dark magic")
</font>pacman_game(int(input("Enter c :")))</pre>
</body>
</html>
