<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/14/2120772_sayed_afridi_ass03_-_SAYED_AFRIDI.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab3_Submission/17/22301368_md_kamrul_islam_cse422_17_assignment03_fall2024_-_Md._Kamrul_Islam_(Niloy).py<p></p><pre>
# -*- coding: utf-8 -*-
"""22301368_Md.Kamrul_Islam_CSE422_17_Assignment03_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yHcyaXV-Xj5bkaIjrh-myfjzjQ7C1aD3
"""

#task:01
import random

def generate_terminalvalues(t_depth): #tottal leaf
    numofleaves = 2 ** t_depth
    terminalvalue = []
    for _ in range(numofleaves):  #generating leaf node.
        random_value = random.choice([-1, 1])
        terminalvalue.append(random_value)  #added
    return terminalvalue

def alpha_beta_recur(leafvalue, c_depth, alpha, beta, is_maximi, c_index):
    if c_depth == 0:
        return leafvalue[c_index[0]]

<a name="0"></a><font color="#FF0000"><a href="match237-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

    if is_maximi:
        max_value = float('-inf')  #initialize
        for base in range(2):  #two basees
            value = alpha_beta_recur(
                leafvalue,
                c_depth - 1,
                alpha,
                beta,
                False,  #miniming for next player.
                c_index
            )
            max_value = max(max_value, value)
            alpha = max(alpha, max_value)
            if beta &lt;= alpha:  #Prunning base
                break
        return max_value
    else:
        min_value = float('inf')  #initialize
        for base in range(2):  #two basees
            value = alpha_beta_recur(
                leafvalue,
                c_depth - 1,
                alpha,
                beta,
                True,  #miniming for next player.
                c_index
            )
            min_value = min(min_value, value)
            beta = min(beta, min_value)
            if beta &lt;= alpha:  #prunning base
</font>                break
        return min_value

def simulate_multiplerounds(initial, t_roundcount):
    playerAwin = 0
    playerBwin = 0
    game_result = []

    c_turnplayer = initial

    for roundnumber in range(1, t_roundcount + 1):
        t_depth = 5         #generating terminal values for this round.
        round_terminalvalue = generate_terminalvalues(t_depth)

        # Use a list to track the index recursion.
        c_leaf_index = [0]

        # winner of this round.
        round_winner = alpha_beta_recur(
            round_terminalvalue,
            t_depth,
            float('-inf'),
            float('inf'),
            c_turnplayer == 0,  #maximizer is Player A.
            c_leaf_index
        )

        if round_winner == 1:  #player B wins the round.
            playerBwin += 1
            game_result.append(f"Winner of Round {roundnumber}: Sub-Zero")
        else:  #player A wins the round.
            playerAwin += 1
            game_result.append(f"Winner of Round {roundnumber}:Scorpion")

        #alternate for next round.
<a name="1"></a><font color="#00FF00"><a href="match237-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

        c_turnplayer = 1 - c_turnplayer

    overall_winner = "Player A" if playerAwin &gt; playerBwin else "Player B"

    print(f"Game Winner: {overall_winner}")
    print(f"Total Rounds Played: {t_roundcount}")
    for result in game_result:
        print(result)

# Input
starting_player = int(input("Enter the starting player (0 for Player A= Scorpion, 1 for Player  B= Sub-Zero): "))
simulate_multiplerounds(initial=starting_player, t_roundcount=5)
</font>
#task02
def minimaxOfAB(level, pacman_turn, values, A, B):
    # Base case:
    if level == 3:
        return values.pop(0)

    if pacman_turn:
        maxValue = -999  # Pac-Man max
        for i in range(2):  # 2 branch
            outcome = minimaxOfAB(level + 1, False, values, A, B)
            maxValue = max(maxValue, outcome)
            A = max(A, outcome)
            if B &lt;= A:  #pruning
                break
        return maxValue
    else:
        minValue = 999  # Ghost mini
        for j in range(2):
            outcome = minimaxOfAB(level + 1, True, values, A, B)
            minValue = min(minValue, outcome)
            B = min(B, outcome)
            if B &lt;= A:  # pruning
                break
        return minValue

def mini_maxDarkMagic(values, c): # calculating
    l_Value = values[1] - c  # magic on left subtree
    r_Value = values[4] - c  # magic on right subtree
    return l_Value, r_Value


def pacman_game(c): # Main\
    values = [3, 6, 2, 3, 7, 1, 2, 0] #initial leaf nodes

    #magic chara mini-max:
    prun_V = values[:]
    minimax_ValueNum = minimaxOfAB(0, True, prun_V, -float('inf'), float('inf'))

    with_leftMagic, with_rightMagic = mini_maxDarkMagic(values, c)

    print(f"The final value of the root node without using dark magic: {minimax_ValueNum}")

    # dark magic er sathe compare:
    if with_leftMagic &gt; minimax_ValueNum or with_rightMagic &gt; minimax_ValueNum:
        if with_rightMagic &gt; with_leftMagic:
            print(f"The new minimax value is {with_rightMagic}. Pacman goes right and uses dark magic")
        else:
            print(f"The new minimax value is {with_leftMagic}. Pacman goes left and uses dark magic")
    else:
        print(f"The minimax value is {minimax_ValueNum}. Pacman does not use dark magic")


pacman_game(2)
#pacman_game(5)</pre>
</body>
</html>
